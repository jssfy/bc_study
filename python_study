




----------- 2016-12-09 18:28:24
我们知道unicode是一种编码标准，具体的实现标准可能是utf-8，utf-16，gbk ......
Python 在内部使用两个字节来存储一个unicode，使用unicode对象而不是str的好处，就是unicode方便于跨平台。
你可以用如下两种方式定义一个unicode:（在python2中）
1 s1 = u"人生苦短"
2 s2 = unicode("人生苦短", "utf-8")
python3
字符串实际就是用的unicode，直接s = "人生苦短"
py3定义bytes使用sb = b'dfja'

http://blog.163.com/jackylau_v/blog/static/1757540402011111114310418/
python在安装时，默认的编码是ascii，当程序中出现非ascii编码时，python的处理常常会报这样的错UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)，python没办法处理非ascii编码的，此时需要自己设置将python的默认编码，一般设置为utf8的编码格式。
  sys.getdefaultencoding()
  sys.setdefaultencoding('utf8') # 可能会报AttributeError: 'module' object has no attribute 'setdefaultencoding'的错误，执行reload(sys)，在执行以上命令就可以顺利通过。

http://www.jb51.net/article/55759.htm
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> name = '老齐'
>>> name
'\xe8\x80\x81\xe9\xbd\x90'
>>> print name
老齐

python2默认的编码是ascii，通过encode可以将对象的编码转换为指定编码格式，而decode是这个过程的逆过程。
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> name = '老齐'
>>> name
'\xe8\x80\x81\xe9\xbd\x90'
>>> print name
老齐
>>> name.decode()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> b = name.decode()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> len(name)
6
>>> b = name.decode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> b = name.decode('utf-8')
>>> b
u'\u8001\u9f50'
>>> print b
老齐
>>> len(b)
2
>>> sys.getdefaultencoding()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sys' is not defined
>>> import sys
>>> sys.getdefaultencoding()
'ascii'

解决办法：在出现问题的页加上如下三行即可：
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

>>> import sys
>>> reload(sys)
<module 'sys' (built-in)>
>>> sys.setdefaultencoding('utf-8')
>>> c = name.decode()
>>> print c
老齐
>>> len(c)
2

http://blog.csdn.net/lxdcyh/article/details/4018054
字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 
decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。 
encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode('gb2312')，表示将unicode编码的字符串str2转换成gb2312编码。 
因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码
因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码

代码中字符串的默认编码与代码文件本身的编码一致。 
如：s='中文'
如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件。 
如果字符串是这样定义：s=u'中文'
则该字符串的编码就被指定为unicode了，即Python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。
如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断：
isinstance(s, unicode)  #用来判断是否为unicode 
用非unicode编码形式的str来encode会报错 

$ file test.py 
test.py: Python script, UTF-8 Unicode text executable


#!encoding=utf-8
name = '老齐'
print type(name.decode('utf-8'))
  
  without the 'encoding' declaration, there will be below error:
  SyntaxError: Non-ASCII character '\xe8' in file test.py on line 7, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details

both #coding=utf-8 and #!encoding=utf-8 work, without this declaration, using chinese in the .py file will fail.

    #!/usr/bin/env python  
    #coding=utf-8  
    s="中文"  
      
    if isinstance(s, unicode):  
    #s=u"中文"  
        print s.encode('gb2312')  
    else:  
    #s="中文"  
        print s.decode('utf-8').encode('gb2312')  

https://zhidao.baidu.com/question/2011216720057745028.html
python怎么知道一个字符串的编码方式
安装chardet模块
chardet文件夹放在/usr/lib/python2.4/site-packages目录下
>>> import chardet
>>> chardet.detect("我")
{'confidence': 0.505, 'encoding': 'utf-8'}


# coding=utf-8
name = '老齐'
print (name.decode('utf-8'))
print (name.decode('utf-8').encode('utf-8'))
$ python test.py
老齐
老齐

http://blog.csdn.net/chenggong2dm/article/details/7677028
#coding=utf-8
#-*- coding: utf-8 -*-
一直搞不清楚这俩头什么区别。直觉上一样。今天特意查了一下，大致明白了：
对于Python解释器来说，这两种写法一样。但是对于编辑器来讲，可能会出现识别问题。
参考：http://www.python.org/dev/peps/pep-0263/
Defining the Encoding
    Python will default to ASCII as standard encoding if no other
    encoding hints are given.
    To define a source code encoding, a magic comment must
    be placed into the source files either as first or second
    line in the file, such as:
          # coding=<encoding name>
    or (using formats recognized by popular editors)
          #!/usr/bin/python
          # -*- coding: <encoding name> -*-
    or
          #!/usr/bin/python
          # vim: set fileencoding=<encoding name> :


len(unicode) returns the number of unicodes instead of number of bytes, but len(str) e.g., when str is a utf-8 string, then the result is a length of bytes.
  this link might help: http://www.linuxidc.com/Linux/2015-02/112973.htm

http://www.jb51.net/article/55759.htm
  python中如何避免中文是乱码
  这个问题是一个具有很强操作性的问题。我这里有一个经验总结，分享一下，供参考：
  首先，提倡使用utf-8编码方案，因为它跨平台不错。
  经验一：在开头声明：
  # -*- coding: utf-8 -*-
  有朋友问我-*-有什么作用，那个就是为了好看，爱美之心人皆有，更何况程序员？当然，也可以写成：
  # coding:utf-8
  经验二：遇到字符（节）串，立刻转化为unicode，不要用str()，直接使用unicode()
  unicode_str = unicode('中文', encoding='utf-8')
  print unicode_str.encode('utf-8')
  经验三：如果对文件操作，打开文件的时候，最好用codecs.open，替代open(这个后面会讲到，先放在这里)
  import codecs
  codecs.open('filename', encoding='utf8')

------- 2016-12-09 18:14:40


由于Python源代码也是一个
文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
#!/usr/bin/env python
# -*- coding: utf-8 -*-
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
如果你使用Notepad++进行编辑，除了要加上# -*- coding: utf-8 -*-外，中文字符串必须是Unicode字符串

print len(u'中文')
2

print len('中文')
6


----------- 2016-12-09 18:06:22

取一个list或tuple的部分元素是非常常见的操作。
对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。


------------- 2016-12-08 13:34:50

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略： >>> L[:3]
类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片

后10个数： >>> L[-10:]

前10个数，每两个取一个： >>> L[:10:2]

所有数，每5个取一个： >>> L[::5]

甚至什么都不写，只写[:]就可以原样复制一个list：

tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： >>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)

字符串'xxx'或Unicode字符串u'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串


----------- 2016-12-07 11:34:59

python中的字符串格式函数str.format()

1 #使用str.format()函数  
2  
3 #使用'{}'占位符  
4 print('I\'m {},{}'.format('Hongten','Welcome to my space!'))  
5 >>> I'm Hongten,Welcome to my space!  
6 print('#' * 40)  
7  
8 #也可以使用'{0}','{1}'形式的占位符  
9 print('{0},I\'m {1},my E-mail is {2}'.format('Hello','Hongten','hongtenzone@foxmail.com')) 

----------- 2016-12-06 18:15:55

$ sudo python runcrawler.py stop
Stopping...
Exception SystemExit: SystemExit(0,) in <module 'threading' from '/usr/lib/python2.7/threading.pyc'> ignored
Exception SystemExit: SystemExit(0,) in <module 'threading' from '/usr/lib/python2.7/threading.pyc'> ignored
Stopped




---------- 2016-12-06 10:46:55
python以其优美的语法和方便的内置数据结构，赢得了不少程序员的亲睐。
其中有个很有用的数据结构，就是字典（dict），使用非常简单。说到遍历一个dict结构，我想大多数人都会想到 for key in dictobj 的方法，确实这个方法在大多数情况下都是适用的。
#这里初始化一个dict
>>> d = {'a':1, 'b':0, 'c':1, 'd':0}
#本意是遍历dict，发现元素的值是0的话，就删掉
>>> for k in d:
...   if d[k] == 0:
...     del(d[k])
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: dictionary changed size during iteration
#结果抛出异常了，两个0的元素，也只删掉一个。
>>> d
{'a': 1, 'c': 1, 'd': 0}

>>> d = {'a':1, 'b':0, 'c':1, 'd':0}
#d.keys() 是一个下标的数组
>>> d.keys()
['a', 'c', 'b', 'd']
#这样遍历，就没问题了，因为其实其实这里遍历的是d.keys()这个list常量。
>>> for k in d.keys():
...   if d[k] == 0:
...     del(d[k])
...
>>> d
{'a': 1, 'c': 1}
#结果也是对的

遍历dict的时候，养成使用 for k in d.keys() 的习惯。
不过，如果是多线程的话，这样就绝对安全吗？也不见得：当两个线程都取完d.keys()以后，如果两个线程都去删同一个key的话，先删的会成功，后删的那个肯定会报 KeyError ，这个看来只能通过其他方式来保证了。

for (d,x) in dict.items():
     print "key:"+d+",value:"+str(x)

for d,x in dict.items():
    print "key:"+d+",value:"+str(x)

------------ 2016-12-06 10:45:14
第一种，最常用的，通过for in遍历数组
colours = ["red","green","blue"]
for colour in colours:
    print colour
# red
# green
# blue
                                下面的方法可以先获得数组的长度，然后根据索引号遍历数组，同时输出索引号
colours = ["red","green","blue"]
for i in range(0, len(colours)):
    print i, colour[i]

---------- 2016-12-05 19:03:55
string treated as a func:

    def crawl(self):
        self.logger.info('crawl for AllInfoSpider')
        try:
            indexes = get_information_measurements()
            index_str = ",".join(indexes)
            codes = eval(self.definition.codes)()

            date = time.strftime('%Y-%m-%d',time.localtime(time.time()))
            for i in range(len(codes)):
                self.logger.info('send websocket request: %s on %s' % (self.counter, date))
                self.crawl_index_data(codes[i], date, date, index_str)
                self.logger.info('crawl finished: %s for code %s' % (self.counter, codes[i]))
                self.counter += 1
        except Exception, e:
            self.logger.info('send websocket request error: %s' % e)

--------- 2016-12-05 14:34:33
dict ops:
    def process_response(self, response, **kwargs):
        # self.logger.info('got response: %s' % response)
        temp = simplejson.JSONDecoder().decode(response)
        self.logger.info('decode type: %s' % type(temp['data']))
        result = simplejson.JSONDecoder().decode(temp['data'])
        self.logger.info('errorCode: %s' % result['errorCode'])
        for key, value in result.items():
            self.logger.info('%s: %s' % (key, type(value)))

2016-12-05 14:33:43,562 - 14831 - INFO - errorCode: -40521009
2016-12-05 14:33:43,563 - 14831 - INFO - errorCode: <type 'int'>
2016-12-05 14:33:43,563 - 14831 - INFO - codeList: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - data: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - fieldList: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - timeList: <type 'list'>


list ops:



------------ 2016-12-05 11:19:53
  #类定义  
  class people:  
      #定义基本属性  
      name = ''  
      age = 0  
      #定义私有属性,私有属性在类外部无法直接进行访问  
      __weight = 0  
      #定义构造方法  
      def __init__(self,n,a,w):  
          self.name = n  
          self.age = a  
          self.__weight = w  
      def speak(self):  
          print("%s is speaking: I am %d years old" %(self.name,self.age))  
  p = people('tom',10,30)  
  p.speak()  


class A(object):    # A must be new-style class
  def __init__(self):
   print "enter A"
   print "leave A"

class B(C):     # A --> C
  def __init__(self):
   print "enter B"
   super(B, self).__init__()
   print "leave B"
　　尝试执行上面同样的代码，结果一致，但修改的代码只有一处，把代码的维护量降到最低，是一个不错的用法。因此在我们的开发过程中，super关键字被大量使用，而且一直表现良好。
　　在我们的印象中，对于super(B, self).__init__()是这样理解的：super(B, self)首先找到B的父类（就是类A），然后把类B的对象self转换为类A的对象（通过某种方式，一直没有考究是什么方式，惭愧），然后“被转换”的类A对象调用自己的__init__函数。考虑到super中只有指明子类的机制，因此，在多继承的类定义中，通常我们保留使用类似代码段1的方法。

------------ 2016-12-05 10:59:31
Python pass是空语句，是为了保持程序结构的完整性。
pass 不做任何事情，一般用做占位语句。

------------- 2016-12-03 18:30:51
一个包是一个带有特殊文件 __init__.py 的目录。__init__.py 文件定义了包的属性和方法。其实它可以什么也不定义；可以只是一个空文件，但是必须存在。如果 __init__.py 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。

__init__.py 文件会在导入时被执行。

__init__.py 中还有一个重要的变量，叫做 __all__。我们有时会使出一招“全部导入”，也就是这样：
from PackageName import *
这时 import 就会把注册在包 __init__.py 文件中 __all__ 列表中的子模块和子包导入到当前作用域中来。比如：
#文件 __init__.py
__all__ = ["Module1", "Module2", "subPackage1", "subPackage2"]
测试：
>>> from Package1 import *


--------- 2016-12-03 18:08:59
object 对象是所有内建类型及 new-style class 的祖先。 object 对象定义了一系列特殊方法(参见 5.3 节后半部分)实现所有对象的默认行为。
__new__, __init__ 方法
你可以创建 object 的直接子类，静态方法 __new__()用来创建类的实例， 实例的 __init__() 方法用来初始化自己。 默认的 __init__() 方法会忽略你传递过来的任何参数。

Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。
只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。
记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。

python当函数的参数不确定时，可以使用*args和**kwargs。*args没有key值，**kwargs有key值,下面看例子
#coding=utf8
__author__ = 'Administrator'
# 当函数的参数不确定时，可以使用*args和**kwargs。*args没有key值，**kwargs有key值
def fun_var_args(farg, *args):
    print 'args:', farg
    for value in args:
        print 'another arg:',value
# *args可以当作可容纳多个变量组成的list或tuple
fun_var_args(1, 'two', 3, None)
#args: 1
#another arg: two
#another arg: 3
#another arg: None
def fun_var_kwargs(farg, **kwargs):
    print 'args:',farg
    for key in kwargs:
        print 'another keyword arg:%s:%s' % (key, kwargs[key])

--------- 2016-11-21 17:02:24
python字符串转json对象，需要使用json模块的loads函数
import json
          jo = json.loads(result)
            print len(jo['data'])
            for info in infos:
                print jo['data'][0]['secID']

$ python tushare_test.py 
/data/v1/api/equity/getEqu.json?field=&ticker=000001&secID=&equTypeCD=&listStatusCD=
{"retCode":1,"retMsg":"Success","data":[{"secID":"000001.XSHE","ticker":"000001","exchangeCD":"XSHE","ListSectorCD":1,"ListSector":"主板","transCurrCD":"CNY","secShortName":"平安银行","secFullName":"平安银行股份有限公司","listStatusCD":"L","listDate":"1991-04-03","equTypeCD":"A","equType":"沪深A股","exCountryCD":"CHN","partyID":2,"totalShares":17170411400,"nonrestFloatShares":14631180400,"nonrestfloatA":14631180400,"officeAddr":"广东省深圳市罗湖区深南东路5047号","primeOperating":"(一)吸收公众存款；(二)发放短期、中期和长期贷款；(三)办理国内外结算；(四)办理票据承兑与贴现；(五)发行金融债券；(六)代理发行、代理兑付、承销政府债券；(七)买卖政府债券、金融债券；(八)从事同业拆借；(九)买卖、代理买卖外汇；(十)从事银行卡业务；(十一)提供信用证服务及担保；(十二)代理收付款项及代理保险业务；(十三)提供保管箱服务；(十四)结汇、售汇业务；(十五)离岸银行业务；(十六)资产托管业务；(十七)办理黄金业务；(十八)财务顾问、资信调查、咨询、见证业务；(十九)经有关监管机构批准的其他业务。","endDate":"2016-09-30","TShEquity":198228000000}]}

--------- 2016-11-21 14:42:19

$ python tushare_information.py 
/usr/lib/python2.7/dist-packages/pkg_resources.py:1031: UserWarning: /home/kidd/.python-eggs is writable by group/others and vulnerable to attack when used with get_resource_filename. Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
  warnings.warn(msg, UserWarning)
/usr/local/lib/python2.7/dist-packages/tushare/stock/classifying.py:93: FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....)
  df = df.sort('area').reset_index(drop=True)
got 2997 rows
Traceback (most recent call last):
  File "tushare_information.py", line 55, in <module>
    output.write(result.ix[i]['code'] + ': ' + result.ix[i]['name'] + '\n')
  File "/usr/lib/python2.7/codecs.py", line 688, in write
    return self.writer.write(data)
  File "/usr/lib/python2.7/codecs.py", line 351, in write
    data, consumed = self.encode(object, self.errors)
  File "/usr/lib/python2.7/encodings/utf_8_sig.py", line 82, in encode
    return encode(input, errors)
  File "/usr/lib/python2.7/encodings/utf_8_sig.py", line 15, in encode
    return (codecs.BOM_UTF8 + codecs.utf_8_encode(input, errors)[0], len(input))
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 8: ordinal not in range(128)

http://stackoverflow.com/questions/9644099/python-ascii-codec-cant-decode-byte
  output.write(result.ix[i]['code'] + ': ' + result.ix[i]['name'].decode('utf-8') + ' and name: ' + result.ix[i][returned_class_name].decode('utf-8') + '\n')


------------- 2016-11-21 12:20:03
1   import a_module
2   print a_module.__file__

上述代码将范围 .pyc 文件被加载的路径，如果需要跨平台解决方案，可用下面代码：
1   import os
2   path =os.path.dirname(amodule.__file__)


------------- 2016-11-17 20:25:51
import pymongo
import time
import datetime
import urllib2
from WindPy import *

print time.mktime(datetime.datetime.now().timetuple())

=> 
D:\abc\samples>python t.pyp
Traceback (most recent call last):
  File "t.pyp", line 8, in <module>
    print time.mktime(datetime.datetime.now().timetuple())
AttributeError: type object 'datetime.time' has no attribute 'mktime'

but there is no such error after putting "from WindPy import *" at the front.


-------- 2016-11-17 10:06:38
Traceback (most recent call last):
  File "/home/kidd/workspace/python/windpy/crawl_performance.py", line 17, in <module>
    for code in codes:
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 904, in next
    if len(self.__data) or self._refresh():
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 865, in _refresh
    limit, self.__id))
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 800, in __send_message
    self.__uuid_subtype)
  File "/usr/lib/python2.7/dist-packages/pymongo/helpers.py", line 94, in _unpack_response
    cursor_id)
pymongo.errors.OperationFailure: cursor id '55721940917' not valid at server

do not keep cursor all the time:
  code_col = info_db.wind_wset
  bak_codes = code_col.find()

----------- 2016-11-09 16:22:52
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> print sys.path
['', '/usr/local/lib/python2.7/dist-packages/rospkg-1.0.39-py2.7.egg', '/usr/local/lib/python2.7/dist-packages/MySQL_python-1.2.5-py2.7-linux-x86_64.egg', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages/PILcompat', '/usr/lib/python2.7/dist-packages/gtk-2.0', '/usr/lib/pymodules/python2.7', '/usr/lib/python2.7/dist-packages/ubuntu-sso-client', '/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode']

$ pip install pymongo
Requirement already satisfied (use --upgrade to upgrade): pymongo in /usr/lib/python2.7/dist-packages


------------ 2016-11-09 11:12:02
def test():
  exit()

test()
print "Good bye!" # this line will not be output!!!

-------- 2016-11-04 11:15:05
python 执行时是如何查找包和模块的 
python 执行一个文件，无论执行的方式是绝对路径还是相对路径，解释器都会把文件所在的目录加入到系统查找路径中，也就是 sys.path 这个 list 中，而 sys.path 又是由系统的 python 环境变量决定的。 


---------- 2016-11-04 10:26:53
1. 如果模块是被导入，__name__的值为模块名字
2. 如果模块是被直接执行，__name__的值为’__main__’

Python中比较特别,导入文件夹下的py文件,则这个目录下必须要有一个__init__.py文件才可
Python的import包含文件功能就跟PHP的include类似，但更确切的说应该更像是PHP中的require，因为Python里的import只要目标不存在就报错程序无法往下执行。要包含目录里的文件，PHP中只需要给对路径就OK。Python中则不同，
提示找不到这个模块的名字 dir.b 。通过查找官方文档，发现要包含目录下的文件时需要在目录下声明一个__init__.py文件，即使这个文件是空的也可以。当然这个文件也可以初始一些数据。
__init__.py seems not necessary if the module is under the same directory.

~/software/python/test
$ tree
.
├── test.py
└── tools
    ├── __init__.py
    ├── __init__.pyc
    ├── tools.py
    └── tools.pyc


---------- 2016-11-04 10:38:09 
pyc
https://www.zhihu.com/question/30296617
        A program doesn't run any faster when it is read from a ‘.pyc’ or ‘.pyo’ file than when it is read from a ‘.py’ file; the only thing that's faster about ‘.pyc’ or ‘.pyo’files is the speed with which they are loaded.
        When a script is run by giving its name on the command line, the bytecode for the script is never written to a ‘.pyc’ or ‘.pyo’ file. Thus, the startup time of a script may be reduced by moving most of its code to a module and having a small bootstrap script that imports that module. It is also possible to name a ‘.pyc’ or ‘.pyo’file directly on the command line.

在你 import 别的 py 文件时，那个 py 文件会被存一份 pyc 加速下次装载。而主文件因为只需要装载一次就没有存 pyc，你可以写两个 a.py 和 b.py，一个 import 另一个试试看。 

当我们运行python文件程序的时候，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。因此总的来说，它具有以下三条特性

    源码距离底层更远（根据官方文档的解释。不说，你们也感觉得到）(。・`ω´・)
    运行时都需要生成字节码，交由虚拟机执行。（你们问我虚拟机在哪儿？！你们也不看看各自都是用什么软件执行的！没错，就是解释器，别和我说是IDLE啊。虚拟机具体实现了由switch-case语句构成的框架函数PyEval_EvalFrameEx，刚刚说的字节码就是这货执行的）
    每次执行脚本，虚拟机总要多出加载和链接的流程。（所以呢，相比于编译型语言就有点慢了。这与“有丝分裂间期”一样，准备东西也要花时间啊！）


毕竟对于比较大的项目，要将PyCodeObject写回硬盘也是不可避免地要花些时间的，而且它又不知道你是不是也就只执行一次，之后就对刚刚跑完的脚本“弃之不顾”了呢。不过，它其实也有贴心的一面。比如，

    若你在命令行直接输入“python path/to/projectDir”（假设projectDir目录含有“__main__.py”文件，以及其他将要调用的模块），那么程序运行结束后便自动为当前目录下所有的脚本生成字节码文件，并保存于本地新文件夹__pycache__当中。（这也有可能是IDE写小项目时自动生成.pyc文件的原因，不过问题描述略微暧昧。详情参见上面知乎问题板块）

或者是，在命令行输入“python path/to/projectDir/__main__.py”，则生成除__main__.py外脚本的字节码文件。不过总的来说，上述这两种行为都大大缩短了项目运行前的准备时间（毕竟分工明确的程序，规模应该不会太小，复用率也不会太低。除非吃饱了撑着，搞出这么多事情(Θ皿Θメ)）
模块在每次导入前总会检查其字节码文件的修改时间是否与自身的一致。若是则直接从该字节码文件读取内容，否则源模块重新导入，并在最后生成同名文件覆盖当前已有的字节码，从而完成内容的更新（详见import.py）。

http://www.tuicool.com/articles/iYRfe2
如果你需要 python 讲一个文件夹作为 package 执行，那么这个文件夹中必须包含一个名为 __main__.py 的文件，当执行 python -m hhlb 或者 python hhlb 的时候，这个文件中的代码都会被执行。

---------- 2016-11-01 14:36:14

    sudo apt-get install 安装的package存放在 /usr/lib/python2.7/dist-packages目录中
    pip 或者 easy_install安装的package存放在/usr/local/lib/python2.7/dist-packages目录中
    手动从源代码安装的package存放在site-packages目录中

----------- 2016-11-02 10:13:52

在Ubuntu14.04上，建议通过下面的方法安装，这是一种通用的方法，也适用于Windows，当然在Windows下

手动下载下来就行了

wget https://bootstrap.pypa.io/get-pip.py  --no-check-certificate [vpn is necessary]
sudo python get-pip.py

如果在Ubuntu14.04上你用sudo apt-get install python-pip下载安装，在使用时有可能出现下面的问题
复制代码

root@ubt:~# pip 
Traceback (most recent call last):
  File "/usr/bin/pip", line 9, in <module>
    load_entry_point('pip==1.5.4', 'console_scripts', 'pip')()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 351, in load_entry_point
    return get_distribution(dist).load_entry_point(group, name)
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2363, in load_entry_point
    return ep.load()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2088, in load
    entry = __import__(self.module_name, globals(),globals(), ['__name__'])
  File "/usr/lib/python2.7/dist-packages/pip/__init__.py", line 11, in <module>
    from pip.vcs import git, mercurial, subversion, bazaar  # noqa
  File "/usr/lib/python2.7/dist-packages/pip/vcs/mercurial.py", line 9, in <module>
    from pip.download import path_to_url
  File "/usr/lib/python2.7/dist-packages/pip/download.py", line 25, in <module>
    from requests.compat import IncompleteRead
ImportError: cannot import name IncompleteRead

复制代码

这是因为通过apt-get安装的pip版本太老了，老的pip版本依赖requests.compat.IncompleteRead，而在2.4.0版本的requests中已经移除了

requests.compat.IncompleteRead，解决方法是先卸载pip（命令为sudo apt-get remove python-pip），然后再用上面的方法重新安装。

有时，还会遇到下面的SSL错误

/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.

安装下面几个包

pip install pyopenssl ndg-httpsclient pyasn1

如果还有问题，再安装下面的包

sudo apt-get install libffi-dev libssl-dev

 

安装完后，测试一下吧，发现不能识别pip这个命令，额，我也不知道怎么回事，解决办法是在/usr/bin目录下建一个软链接，指向到/usr/local/bin/pip
复制代码

njsqrt3@temp-test2:~$ pip
-bash: /usr/bin/pip: No such file or directory        # $PATH的值包含/usr/bin
njsqrt3@temp-test2:~$ which pip
/usr/local/bin/pip                                    # $PATH的值包含/usr/local/bin
njsqrt3@temp-test2:~$ 
njsqrt3@temp-test2:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
njsqrt3@temp-test2:~$

------------------- 2016-11-02 10:16:14
$ sudo python get-pip.py 
The directory '/home/kidd/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
The directory '/home/kidd/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
Collecting pip
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  Downloading pip-8.1.2-py2.py3-none-any.whl (1.2MB)
    100% |████████████████████████████████| 1.2MB 763kB/s 
Collecting wheel
  Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB)
    100% |████████████████████████████████| 71kB 1.2MB/s 
Installing collected packages: pip, wheel
Successfully installed pip-8.1.2 wheel-0.29.0
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
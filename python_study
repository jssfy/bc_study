

libs

beautifulsoup
  https://www.crummy.com/software/BeautifulSoup/


---------- 2017-03-14 16:15:10
import sys
sys.stdout.write('.')

# 在 python 2.x 下用 python 3 的 print
from __future__ import print_function
print('.', end='')

# ps. 这种写法并不是正确的，会在末尾多一个空格
print '.',

作者：李寒
链接：https://www.zhihu.com/question/20390166/answer/20034584
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


for i in range(10):
    print i,
    sys.stdout.flush()
    time.sleep(1)

print i,在具体执行时,并不会实时显示,每次都是在换行时才把整行指令打出来.
如果要实时显示,需要在每次sys.stdout.write后面加上一行sys.stdout.flush()让屏幕输出

do not put '\r' at the end, the previous output will be cleared.
for i in range(10):
    print '\r' + str(i),
    sys.stdout.flush()
    time.sleep(1)

--------- 2017-03-14 10:12:25
查找Python 安装路径

$ python 
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from distutils.sysconfig import get_python_lib
>>> print(get_python_lib())
/usr/lib/python2.7/dist-packages



------------- 2017-03-14 10:06:00
在UBUNTU系统下，使用python进行语言开发时，在必要时需要安装不同的python包进行扩展。那么，通常用到的两种方式：pip install和ubuntu系统独有的apt-get install有什么区别呢？这里略作记录。
（主要参考：http://askubuntu.com/questions/431780/apt-get-install-vs-pip-install）
pip install的源是pyPI,apt-get 的源是ubuntu仓库。
对于python的包来说，pyPI的源要比ubuntu更多，对于同一个包，
pyPI可以提供更多的版本以供下载。
apt-get 安装的包是系统化的包，在系统内完全安装。
pip install安装的python包，可以只安装在当前工程内
apt-get 和 pip install 中，对于相同python包，命名可能会不同：
apt-get install：对于python2来说，包的名称可能是python-<package_name>
对于python3来说，包的名称可能是python3-<package_name>
pip install:直接使用<package_name>进行下载


---------- 2017-02-27 14:48:26
C:\Users\Administrator\Downloads\codes\uiautomation.pyc
Traceback (most recent call last):
  File "test.py", line 119, in <module>
    main()
  File "test.py", line 98, in main
    get_classifications(tree)
  File "test.py", line 76, in get_classifications
    f.write(s + child.Name + '\n')
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-3: ordinal not in range(128)

f.write(s + child.Name.encode("utf-8") + '\n')
  =>
f.write(s + child.Name + '\n')

------------- 2017-02-24 17:10:54
>>> pattern='\d{4}'
>>> match = re.search(pattern, '一级行业;2016-11-24')
>>> print match.group()
2016


-------- 2017-02-23 16:22:22

hello.py
from mod2.mod2 import info
info()

mod1.py
def info():
  print 'this is mod1'

mod2.py
from mod1 import mod1
def info():
  print 'this is mod2'
  mod1.info()

$ tree
.
├── hello.py
├── mod1
│   ├── __init__.py
│   ├── __init__.pyc
│   ├── mod1.py
│   └── mod1.pyc
└── mod2
    ├── __init__.py
    ├── __init__.pyc
    ├── mod2.py
    └── mod2.pyc

---------- 2017-02-21 10:58:37
uiautomation

http://www.cnblogs.com/Yinkaisheng/p/3444132.html
https://github.com/yinkaisheng/Python-UIAutomation-for-Windows
http://blog.csdn.net/vagabond1/article/details/5648902
https://msdn.microsoft.com/en-us/library/ee684021


----------- 2017-02-17 11:27:46
self.measures = Dataset.get_measures(dataset, id_only = False)
        self.measure_types = {}
        for measure in self.measures:
            measure['id'] = measure['id'].upper()
            self.measure_types[measure['id']] = measure['dataType']
        self.measure_types['date'] = 1 # add 'date' to the list, so that date will be converted to unix time before persistence
        self.day_measures = filter(lambda m: m.get('frequency', None) == 'day', self.measures)

------------- 2017-02-16 14:30:20
datetime, unix timestamp conversion

    format = '%Y-%m-%d' # %H:%M:%S
    for k in stats:
        start = time.strftime(format, time.localtime(stats[k]['start']/1000))

    datetime.now().strftime('%Y-%m-%d')

# -*- coding: utf-8 -*-
import time
def timestamp_datetime(value):
 format = '%Y-%m-%d %H:%M:%S'
 # value为传入的值为时间戳(整形)，如：1332888820
 value = time.localtime(value)
 ## 经过localtime转换后变成
 ## time.struct_time(tm_year=2012, tm_mon=3, tm_mday=28, tm_hour=6, tm_min=53, tm_sec=40, tm_wday=2, tm_yday=88, tm_isdst=0)
 # 最后再经过strftime函数转换为正常日期格式。
 dt = time.strftime(format, value)
 return dt
def datetime_timestamp(dt):
  #dt为字符串
  #中间过程，一般都需要将字符串转化为时间数组
  time.strptime(dt, '%Y-%m-%d %H:%M:%S')
  ## time.struct_time(tm_year=2012, tm_mon=3, tm_mday=28, tm_hour=6, tm_min=53, tm_sec=40, tm_wday=2, tm_yday=88, tm_isdst=-1)
  #将"2012-03-28 06:53:40"转化为时间戳
  s = time.mktime(time.strptime(dt, '%Y-%m-%d %H:%M:%S'))
  return int(s)
if __name__ == '__main__':
 d = datetime_timestamp('2012-03-28 06:53:40')
 print d
 s = timestamp_datetime(1332888820)
 print s


time.strptime(date, "%Y-%m-%d")
  time.struct_time(tm_year=2011, tm_mon=1, tm_mday=8, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=5, tm_yday=8, tm_isdst=-1)

datetime.strptime(date, "%Y-%m-%d") -> datetime

---------- 2017-02-15 16:57:56
datetime.strptime('2016-12-31', '%Y-%m-%d')

-------- 2017-02-15 16:01:13
too many values to unpack
      for k, v in data:

python只支持对于key的遍历，所以不能使用for k,v这种形式，这个时候会提示ValueError: too many values to unpack，使用粗体的形式代替

i.e. you could have done this:

for k in last:
    print "Key is %s, value is %s" % (k, last[k])

Alternatively, you can use the iteritems() method;

for k, v in last.iteritems():
    print "Key is %s, value is %s" % (k, v)

------------ 2017-02-14 14:52:51
BeautifulSoup 技巧
得到某一节点下的所有文本
texts = soup.findAll(text=True)
all_text = "\n".join(texts)


def bs_test():
    # doc = ['<html><head><title>PythonClub.org</title></head>',
    #        '<body><p id="firstpara" align="center">This is paragraph <b>one</b> of ptyhonclub.org.',
    #        '<p id="secondpara" align="blah">This is paragraph <b>two</b> of pythonclub.org.',
    #        '</html>']
    # soup = BeautifulSoup(''.join(doc))
    proxies = []
    try:
        url = 'http://www.pythonclub.org/modules/beautifulsoup/start'
        req = urllib2.Request(url, headers=header)
        res = urllib2.urlopen(req).read()
        soup = BeautifulSoup(res)
        ips = soup.findAll('tr')
        print soup.html.head.title

        print soup.html.head.title.string

        print soup.html.head.title.contents[0]

        print soup.findAll(text=re.compile("para"))[0].parent
        print soup.originalEncoding
    except Exception, ex:
        print ex
    return proxies

---------- 2017-02-14 14:07:47
>>> L=[{'id' : 3 , 'he' : 5}, {'id' : 2 , 'he' : 2}, {'id' : 3 , 'he' : 3 }, {'id' : 5 , 'he' : 1}, {'id' : 1 , 'he' : 4}]
>>> 
>>> L.sort()
>>> print L
[{'id': 5, 'he': 1}, {'id': 2, 'he': 2}, {'id': 3, 'he': 3}, {'id': 1, 'he': 4}, {'id': 3, 'he': 5}]
>>> L=[{'ad' : 3 , 'he' : 5}, {'ad' : 2 , 'he' : 2}, {'ad' : 3 , 'he' : 3 }, {'ad' : 5 , 'he' : 1}, {'ad' : 1 , 'he' : 4}]
>>> print L
[{'ad': 3, 'he': 5}, {'ad': 2, 'he': 2}, {'ad': 3, 'he': 3}, {'ad': 5, 'he': 1}, {'ad': 1, 'he': 4}]

http://blog.csdn.net/liuzhoulong/article/details/7484941
>>> sorted(L, cmp=None, key=lambda t:t['he'], reverse=False)
[{'ad': 5, 'he': 1}, {'ad': 2, 'he': 2}, {'ad': 3, 'he': 3}, {'ad': 1, 'he': 4}, {'ad': 3, 'he': 5}]
>>> sorted(L, cmp=None, key=lambda t:t['ad'], reverse=False)
[{'ad': 1, 'he': 4}, {'ad': 2, 'he': 2}, {'ad': 3, 'he': 3}, {'ad': 3, 'he': 5}, {'ad': 5, 'he': 1}]

-------- 2017-02-14 14:06:41
http://www.cnblogs.com/wanpython/archive/2010/11/01/1865919.html

>>> info = [lambda a: a**3, lambda b: b**3]
>>> info[0](2)
8
下面举几个python lambda的例子吧
1单个参数的：
g = lambda x:x*2
print g(3)
结果是6

2多个参数的：
m = lambda x,y,z: (x-y)*z
print m(3,1,2)
结果是4

---------- 2017-02-14 13:51:34
python合并两个数组
方法1
a=[1,2,3]
b=[4,5,6]
a=a+b
方法2
view sourceprint?
a=[1,2,3]
b=[4,5,6]
a.extend(b)


L=[{'ad' : 3 , 'he' : 5}, {'ad' : 2 , 'he' : 2}, {'ad' : 3 , 'he' : 3 }, {'ad' : 5 , 'he' : 1}, {'ad' : 1 , 'he' : 4}]

-------- 2017-02-13 11:28:31
python proxy

urllib:
        proxy_host = "http://" + proxy_info['host'] + ":" + str(proxy_info['port'])
        proxy_temp = {"http": proxy_host}
        print 'validating ' + proxy_host
        r = urllib.urlopen(url, proxies=proxy_temp).read()

urllib2:
def switch_to_next_proxy():
    # print 'crawl: %s' % url
    # The proxy address and port:
    # proxy_info = get_random_proxy()
    proxy_info = get_next_proxy()
    if not proxy_info:
        print 'No more proxies'
        return False
    # We create a handler for the proxy
    proxy_support = urllib2.ProxyHandler({"http": "http://%(host)s:%(port)d" % proxy_info})
    # We create an opener which uses this handler:
    opener = urllib2.build_opener(proxy_support)
    # Then we install this opener as the default opener for urllib2:
    urllib2.install_opener(opener)
    global _CURRENT_PROXY
    _CURRENT_PROXY = '%s:%d' % (proxy_info['host'], proxy_info['port'])
    print 'switched to: %s' % _CURRENT_PROXY
    return True

def crawl(url, id):
    global _TO_RETRY
    tries = 6

    while tries > 0:
        try:
            r = urllib2.urlopen(url).read()
            break
        except urllib2.HTTPError, e:
            print 'HTTPError: ' + str(e.code)
            tries -= 1
            if tries <= 0:
                return False
        except Exception, ex:
            # need to remove the proxy if found blacklisted, TBD
            print Exception, ":", ex
            # print proxy_info
            tries -= 1
            if tries <= 0:
                return False
            else:
                s = 2 # random.randint(1, 10)
                print 'to sleep a while: ' + str(s)
                time.sleep(s)


------------ 2017-02-10 12:23:33

<urlopen error [Errno 111] Connection refused>


------------- 2017-02-10 11:44:38
http://www.jb51.net/article/90783.htm
python proxy:


------------ 2017-02-10 10:50:33
Traceback (most recent call last):
  File "/home/kidd/workspace/abc/apes-crawler/spiders/filmdetailspider.py", line 217, in <module>
    main()
  File "/home/kidd/workspace/abc/apes-crawler/spiders/filmdetailspider.py", line 208, in main
    if not crawl(url, id):
  File "/home/kidd/workspace/abc/apes-crawler/spiders/filmdetailspider.py", line 170, in crawl
    _db.films.update({'_id': ObjectId(_LAST_OBJECT_ID)}, {'$set': film}, upsert=True)
  File "/usr/local/lib/python2.7/dist-packages/pymongo/collection.py", line 2503, in update
    collation=collation)
  File "/usr/local/lib/python2.7/dist-packages/pymongo/collection.py", line 754, in _update
    _check_write_command_response([(0, result)])
  File "/usr/local/lib/python2.7/dist-packages/pymongo/helpers.py", line 315, in _check_write_command_response
    raise WriteError(error.get("errmsg"), error.get("code"), error)
pymongo.errors.WriteError: '$set' is empty. You must specify a field like so: {$set: {<field>: ...}}

be aware of the potential empty $set param:
_db.films.update({'_id': ObjectId(_LAST_OBJECT_ID)}, {'$set': {}}, upsert=True)

------------ 2017-02-10 10:49:07
fix:
  http://maoyan.com/films?yearId=5&sortId=2&offset=1956007 
    will still return films even the offset is far larger than the real number. 
    use dict to record crawled fild ids and treat it as finished if all crawled filmed are already crawled.

            if _CRAWLED_FILMS.has_key(k):
                # already crawled, skip
                continue
            else:
                _CRAWLED_FILMS[k] = 1

can also use set like below:
>>> a = set(['y', 'b', 'o'])
>>> 'y' in a
True

-------------- 2017-02-09 14:04:50
to fake source ip:

java server:
    public String getIpAddr() {
        String ip = servletRequest.getHeader("x-forwarded-for");
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = servletRequest.getHeader("Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = servletRequest.getHeader("WL-Proxy-Client-IP");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = servletRequest.getRemoteAddr();
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = servletRequest.getHeader("http_client_ip");
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = servletRequest.getHeader("HTTP_X_FORWARDED_FOR");
        }
        // 如果是多级代理，那么取第一个ip为客户ip
        if (ip != null && ip.contains(",")) {
            ip = ip.substring(ip.lastIndexOf(",") + 1, ip.length()).trim();
        }
        return ip;
    }


from faker import Factory
from random import randrange
def get_random_ip():
    """gen random ip address
    """
    not_valid = [10,127,169,172,192]

    first = randrange(1,256)
    while first in not_valid:
        first = randrange(1,256)

    ip = ".".join([str(first),str(randrange(1,256)),
                   str(randrange(1,256)),str(randrange(1,256))])
    return ip


def get_random_ua():
    """gen random ua
    """
    ua = Factory.create()

    return ua.user_agent()

def main():
    try:
        opener = urllib2.build_opener()
        opener.addheaders.append(('Cookie', 'token=eyJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKZXJzZXktU2VjdXJpdHktQmFzaWMiLCJzdWIiOiI1ODNkMzQyODI2ZWZkNDY1NjA1YzM0ZTQiLCJhdWQiOiJ1c2VyIiwiZXhwIjoxNDg2NzIwMTgwLCJpYXQiOjE0ODY1NDczODAsImp0aSI6IjEifQ.cxwXI9P6sO_MhuJGO-EWebOqYaqArsgUCTK_CSzl0cQ'))
        fake_ip = get_random_ip()
        opener.addheaders.append(('X-Forwarded-For', fake_ip))
        opener.addheaders.append(('Proxy-Client-IP', fake_ip))
        opener.addheaders.append(('WL-Proxy-Client-IP', fake_ip))
        opener.addheaders.append(('http_client_ip', fake_ip))
        opener.addheaders.append(('XHTTP_X_FORWARDED_FOR', fake_ip))
        opener.addheaders.append(('User-Agent', get_random_ua()))
        r = opener.open(url).read()
        # r = urllib2.urlopen(url).read()
    except urllib2.HTTPError, e:
        print e.code
        return

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

public class HelloWorld extends HttpServlet {
    private String message;

    @Override
    public void init() throws ServletException {
        message = "Hello world, this message is from servlet!";
    }

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        //设置响应内容类型
        resp.setContentType("text/html");
        //设置逻辑实现
        PrintWriter out = resp.getWriter();
        out.println("<h3>" + message + "</h3>");

        out.println("<br/>x-forwarded-for: " + req.getHeader("x-forwarded-for"));
        out.println("<br/>Proxy-Client-IP: " + req.getHeader("Proxy-Client-IP"));
        out.println("<br/>WL-Proxy-Client-IP: " + req.getHeader("WL-Proxy-Client-IP"));
        out.println("<br/>getRemoteAddr(): " + req.getRemoteAddr());
        out.println("<br/>http_client_ip: " + req.getHeader("http_client_ip"));
        out.println("<br/>HTTP_X_FORWARDED_FOR: " + req.getHeader("HTTP_X_FORWARDED_FOR"));
    }
}

$ python /home/kidd/workspace/python/http/spider.py
last object id loaded: 589806d8c189e5c954bb81a7
<h3>Hello world, this message is from servlet!</h3>
<br/>x-forwarded-for: 38.146.133.179
<br/>Proxy-Client-IP: 38.146.133.179
<br/>WL-Proxy-Client-IP: 38.146.133.179
<br/>getRemoteAddr(): 127.0.0.1
<br/>http_client_ip: 38.146.133.179
<br/>HTTP_X_FORWARDED_FOR: 38.146.133.179

tested with aliyun tomcat java web app: http://123.57.227.173:8080/javaweb_demo/hello
$ python spider.py
last object id loaded: 5898070cc189e5c954bb81e7
<h3>Hello world, this message is from servlet!</h3>
<br/>x-forwarded-for: 211.48.164.132
<br/>Proxy-Client-IP: 211.48.164.132
<br/>WL-Proxy-Client-IP: 211.48.164.132
<br/>getRemoteAddr(): 123.126.24.14
<br/>http_client_ip: 211.48.164.132
<br/>HTTP_X_FORWARDED_FOR: 211.48.164.132


----------- 2017-02-09 11:51:31
sudo pip install fake-factory
sudo pip uninstall fake-factory

ImportError: The ``fake-factory`` package is now called ``Faker``
  faker should by uninstalled. fake-factory==0.7.4 works.

sudo pip install fake-factory==0.7.4

from faker import Factory
    fake = Factory.create()
 
    # OR
    from faker import Faker
    fake = Faker()
 
    fake.name()
    # 'Lucy Cechtelar'
 
    fake.address()
    # "426 Jordy Lodge
    #  Cartwrightshire, SC 88120-6700"
 
    fake.text()

----------- 2017-02-09 10:35:39
socket.error: [Errno 104] Connection reset by peer

def crawl(url, id):
    tries = 5
    while tries > 0:
        try:
            r = urllib2.urlopen(url).read()
            break
        except urllib2.HTTPError, e:
            print 'HTTPError: ' + str(e.code)
            tries -= 1
            if tries <= 0:
                return False
        except Exception, ex:
            print Exception, ":", ex
            tries -= 1
            if tries <= 0:
                return False

------------- 2017-02-08 20:12:43
UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-3: ordinal not in range(128)

http://blog.csdn.net/junshao90/article/details/7974030
字符集的问题，在文件前加两句话：
  reload(sys)
  sys.setdefaultencoding('utf-8')


print sys.getdefaultencoding()
  ascii
基本上是ascii编码方式，由此Python自然调用ascii编码解码程序去处理字符流，当字符流不属于ascii范围内，就会抛出异常（ordinal not in range(128)）。

解决的方案很简单，修改默认的编码模式，很多朋友会想到setdefaultencoding，是的，我们可以通过sys.setdefaultencoding(‘utf-8’)来将当前的字符处理模式修改为utf-8编码模式，值得注意的是，如果单纯这么调用的话，Python会抛出一个AttributeError异常：竟然说sys没有setdefaultencoding的方法，其实sys是有这个方法的，但是要请出她老人家需要调用一次reload(sys)


----------- 2017-02-08 17:19:40
https://docs.python.org/2/library/urlparse.html

url = 'http://www.something.com:1234/foo/index.html?name=kzc&age=29#second'
>> up = urlparse.urlparse(url)
>> up.scheme
'http'
>> up.hostname
'www.something.com'
>> up.port
1234
>> up.path
'/foo/index.html'
>> up.query
'name=kzc&age=29'
>> up.fragment
'second'

_START_URL = 'http://maoyan.com/films?sortId=2&yearId=11'
_NEXT_URL = _START_URL

def construct_next_url(count):
    global _NEXT_URL
    u = urlparse.urlparse(_NEXT_URL)
    query = urlparse.parse_qs(u.query)
    if 'offset' not in query:
        query['offset'] = [count]
    else:
        query['offset'][0] = int(query['offset'][0]) + count
    q = ''
    for k, v in query.items():
        if len(q) != 0:
            q += '&'
        q += '%s=%s' % (k, v[0])
    _NEXT_URL = urlparse.urlunparse((u.scheme, u.netloc, u.path, u.params, q, u.fragment))
    
--------- 2017-02-08 14:52:20
 python去除空格和换行符的方法
一、去除空格
　　strip()
"   xyz   ".strip()            # returns "xyz"  
"   xyz   ".lstrip()           # returns "xyz   "  
"   xyz   ".rstrip()           # returns "   xyz"  
"  x y z  ".replace(' ', '')   # returns "xyz" 
二、替换 replace("space","")
　　用replace("\n", ""),后边的串替换掉前边的

------------ 2017-02-08 12:29:19
excel
import xlrd
def main():
    data = xlrd.open_workbook('measures.xlsx')

    sheets = data.sheets()
    for sheet in sheets:
        print '\n\n\n'
        names = sheet.row_values(0)
        ids = sheet.row_values(1)
        if len(names) != len(ids):
            raise Exception('names and ids not match')
        for i in range(2, len(names)):
            print '%s%s:%s' % (' ' * 12, names[i], ids[i])

if __name__ == '__main__':
    main()


-------- 2017-02-08 11:35:21
在编写程序的时候，如果想为一个在函数外的变量重新赋值，并且这个变量会作用于许多函数中时，就需要告诉python这个变量的作用域是全局变量。此时用global语句就可以变成这个任务，也就是说没有用global语句的情况下，是不能修改全局变量的。

----------- 2017-02-04 19:19:29
python深拷贝浅拷贝 
import copy
f = copy.deepcopy(a)        # 对象拷贝，深拷贝，两个对象完全没关系  
print a is f #False  
print a == f #True  

---------- 2017-02-03 18:15:07
xrange 用法与 range 完全相同，所不同的是生成的不是一个list对象，而是一个生成器。
要生成很大的数字序列的时候，用xrange会比range性能优很多，因为不需要一上来就开辟一块很大的内存空间。


--------- 2017-01-16 11:54:32
Python yield 使用浅析 
如何生成斐波那契數列

改写后的 fab 函数通过返回 List 能满足复用性的要求，但是更有经验的开发者会指出，该函数在运行中占用的内存会随着参数 max 的增大而增大，如果要控制内存占用，最好不要用 List

 for i in xrange(1000): pass
则不会生成一个 1000 个元素的 List，而是在每次迭代中返回下一个数值，内存空间占用很小。因为 xrange 不返回 List，而是返回一个 iterable 对象。

Fab 类通过 next() 不断返回数列的下一个数，内存占用始终为常数：
然而，使用 class 改写的这个版本，代码远远没有第一版的 fab 函数来得简洁。如果我们想要保持第一版 fab 函数的简洁性，同时又要获得 iterable 的效果，yield 就派上用场了
第四个版本的 fab 和第一版相比，仅仅把 print b 改为了 yield b，就在保持简洁性的同时获得了 iterable 的效果。

简单地讲，yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator，调用 fab(5) 不会执行 fab 函数，而是返回一个 iterable 对象！在 for 循环执行时，每次循环都会执行 fab 函数内部的代码，执行到 yield b 时，fab 函数就返回一个迭代值，下次迭代时，代码从 yield b 的下一条语句继续执行，而函数的本地变量看起来和上次中断执行前是完全一样的，于是函数继续执行，直到再次遇到 yield。


-------- 2017-01-16 10:53:26
origin=[0,0]
def create(pos=origin):
    pos[0] = 1
create()
print origin

[1, 0]



------------ 2017-01-16 10:31:26
python中的闭包从表现形式上定义（解释）为：如果在一个内部函数里，对在外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure).
再稍微讲究一点的解释是，闭包=函数块+定义函数时的环境，adder就是函数块，x就是环境，当然这个环境可以有很多，不止一个简单的x。

def addx(x):
    def adder(y):
       return x+y
    return adder

c = addx(8)
print type(c)
print c.__name__ 
print c(10)

output:
  <type 'function'>
  adder
  18

使用闭包注意事项
1.不会改变外部函数中的局部变量

2. 
def foo():
    a=1
    def bar():
        a=a+1
        return a
    return bar

c = foo()
print c() # error

Traceback (most recent call last):
  File "test.py", line 37, in <module>
    print c()
  File "test.py", line 32, in bar
    a=a+1
UnboundLocalError: local variable 'a' referenced before assignment

||

这是因为在执行代码 c = foo()时，python会导入全部的闭包函数体bar()来分析其的局部变量，python规则指定所有在赋值语句左面的变量都是局部变量，则在闭包bar()中，变量a在赋值符号"="的左面，被python认为是bar()中的局部变量。再接下来执行print c()时，程序运行至a = a + 1时，因为先前已经把a归为bar()中的局部变量，所以python会在bar()中去找在赋值语句右面的a的值，结果找不到，就会报错。解决的方法很简单: 只要将a设定为一个容器就可以了。这样使用起来多少有点不爽，所以在python3以后，在a = a + 1 之前，使用语句nonlocal a就可以了，该语句显式的指定a不是闭包的局部变量。

def foo():
    a=[1]
    def bar():
        a[0]=a[0]+1
        return a[0]
    return bar

c = foo()
print c()

3. 在程序里面经常会出现这类的循环语句，Python的问题就在于，当循环结束以后，循环体中的临时变量i不会销毁，而是继续存在于执行环境中。还有一个python的现象是，python的函数只有在执行时，才会去找函数体里的变量的值。
x=9
def addx():
    def adder(y):
       return x+y
    return adder

c = addx()
print type(c)
print c.__name__ 
x = 20
print c(10)

<type 'function'>
adder
30

闭包主要是在函数式开发过程中使用。以下介绍两种闭包主要的用途。
用途1：当闭包执行完后，仍然能够保持住当前的运行环境。 ?? normal function can still do the same thing, as the global variable "origin" is changing - to better understand, put the global variables into the "def create" block, and we can see the variable origin is varying.
if passing the closure to multiple threads, you can see the modifications accumulate, but be careful with the critical zone.

origin=[0,0]
legal_x=[0,50]
legal_y=[0,50]
def create(pos=origin):
    def player(direction,step):
        new_x=pos[0]+direction[0]*step
        new_y=pos[1]+direction[1]*step
        pos[0]=new_x
        pos[1]=new_y
        # pos = [new_x, new_y]
        return pos
    return player
  
player=create()
print player([1,0],10)
print player([0,1],20)
print player([-1,0],10)

用途2：闭包可以根据外部作用域的局部变量来得到不同的结果，这有点像一种类似配置功能的作用，我们可以修改外部的变量，闭包根据这个变量展现出不同的功能。比如有时我们需要对某些文件的特殊行进行分析，先要提取出这些特殊行。

---------- 2017-01-13 10:37:03
send mail:

当传入发送邮箱正确的用户名和密码时，总是收到到：550 User has no permission这样的错误，
其实我们用Java发送邮件时相当于自定义客户端根据用户名和密码进行登录，然后使用SMTP服务发送邮件。但新注册的163邮件默认是不开启客户端授权验证的（对自定的邮箱大师客户端默认开启），
因此登录总是会被拒绝，验证没有权限。解决办法是进入163邮箱，进入邮箱中心——客户端授权密码，选择开启即可

# -*- coding: utf-8 -*-

from email import encoders
from email.header import Header
from email.mime.text import MIMEText
from email.utils import parseaddr, formataddr
import smtplib

def _format_addr(s):
    name, addr = parseaddr(s)
    return formataddr(( \
        Header(name, 'utf-8').encode(), \
        addr.encode('utf-8') if isinstance(addr, unicode) else addr))

# from_addr = raw_input('From: ')
# password = raw_input('Password: ')
# to_addr = raw_input('To: ')
# smtp_server = raw_input('SMTP server: ')

def send_mail_to(dest):
  if dest is None:
    print 'dest is none'
    return

  from_addr = 'anhye_abcft@163.com'
  password = 'Pa55word'
  to_addr = dest
  smtp_server = 'smtp.163.com'

  msg = MIMEText('hello, sent by Python 3...', 'plain', 'utf-8')
  msg['From'] = _format_addr(u'Python爱好者 <%s>' % from_addr)
  msg['To'] = _format_addr(u'管理员 <%s>' % ','.join(to_addr))
  msg['Subject'] = Header(u'来自SMTP的问候……', 'utf-8').encode()

  server = smtplib.SMTP(smtp_server, 25)
  # server.set_debuglevel(1)
  server.login(from_addr, password)
  server.sendmail(from_addr, to_addr, msg.as_string())
  server.quit()

send_mail_to(['309228933@qq.com', 'anhye@abcft.com'])

--------- 2017-01-10 15:19:45
    def _split_date_range(self, start, stop):
        if start.strftime('%Y-%m-%d') == stop.strftime('%Y-%m-%d'):
            yield start.strftime('%Y-%m-%d'), start.strftime('%Y-%m-%d')
        else:
            interval = timedelta(days=10)
            temp = start + interval
            while temp < stop:
                yield start.strftime('%Y-%m-%d'), temp.strftime('%Y-%m-%d')
                start  = temp + timedelta(days=1)
                temp = start + interval
            yield start.strftime('%Y-%m-%d'), stop.strftime('%Y-%m-%d')


-------- 2017-01-10 11:59:48

def load_object(path):
    """Load an object given its absolute object path, and return it.

    object can be a class, function, variable o instance.
    path ie: 'scrapy.contrib.downloadermiddelware.redirect.RedirectMiddleware'
    """

    try:
        dot = path.rindex('.')
    except ValueError:
        raise ValueError("Error loading object '%s': not a full path" % path)

    module, name = path[:dot], path[dot+1:]
    print 'module: ' + module
    print 'name: ' + name
    try:
        mod = __import__(module, {}, {}, [''])
    except ImportError, err:
        raise ImportError("Error loading object '%s': %s" % (path, err))

    try:
        obj = getattr(mod, name)
    except AttributeError:
        raise NameError("Module '%s' doesn't define any object named '%s'" % (module, name))

    return obj

obj = load_object('datetime.date')
now = obj.today()
print now.strftime('%Y-%m-%d')

----------- 2017-01-03 10:33:07
如何获取 Python 模块的路径？ 

from gevent import monkey; monkey.patch_socket()
import gevent
print gevent.__file__
print monkey.__file__

/usr/local/lib/python2.7/dist-packages/gevent/__init__.pyc
/usr/local/lib/python2.7/dist-packages/gevent/monkey.pyc

http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001407503089986d175822da68d4d6685fbe849a0e0ca35000

Python通过yield提供了对协程的基本支持，但是不完全。而第三方的gevent为Python提供了比较完善的协程支持。
当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。
由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成.

线程数只有1个。

使用gevent，可以获得极高的并发性能，但gevent只能在Unix/Linux下运行，在Windows下不保证正常安装和运行。

如果需要跨平台解决方案，可用下面代码：
  import os
  path =os.path.dirname(amodule.__file__)

------------ 2016-12-29 19:44:14
在Python里iterable被认为是一类对象，这类对象能够一次返回它的一个成员（也就是元素）。抽象一点就是
适合迭代的对象。实际上，任何具有__iter__()或__getitem__()方法的对象，Python就认为它是一个iterable。
Python里有大量内置的iterable类型，如： list，str，tuple，dict，file，xrange等。使用内置的iter()函数来生成iterator


--------- 2016-12-28 15:53:09
sys.platform

平台                                    值
Linux (2.x and 3.x)           'linux2'   
Windows                          'win32'   
Windows/Cygwin             'cygwin'   
Mac OS X                        'darwin'   
OS/2                                  'os2'   
OS/2 EMX                       'os2emx'   
RiscOS                             'riscos'   
AtheOS                            'atheos'

稍微区分一下os、sys、platform三个模块
os提供操作系统的接口，常用的有文件系统相关和进程相关
例如：
    os.path.walk (遍历目录)
    os.getpid (获取进程id)
sys提供python解释器系统的通用配置和函数，影响着解释器的行为
注意这里的系统不是操作系统，而是python解释器这个“系统”
例如：
    sys.version (python版本而非os版本)
    sys.path (模块搜索路径，不是os的环境变量)
    sys.getrecursionlimit (最大嵌套调用层数)
    sys.getrefcount (获取对象的引用计数)
platform提供平台相关的信息
例如：
    platform.architecture (操作系统和位数)
    platform.processor (处理器版本)
作者：luobonuo
链接：https://www.zhihu.com/question/23970615/answer/26256689
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

Is it safe to use sys.platform=='win32' check on 64-bit Python?
实际上这个`win32`应该是指Win32 API。
如果你真的很在意架构，那可以用`platform`包
>>> import platform
>>> platform.machine()
AMD64
与Python是不是32位没有关系
作者：钟宇腾
链接：https://www.zhihu.com/question/23970615/answer/26248874
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

----------- 2016-12-28 15:33:23
pdb:

$ python -m pdb test.py
> /home/kidd/workspace/python/test.py(2)<module>()
-> import sys
(Pdb) l
  1   # coding=utf-8
  2  -> import sys
  3   import os
  4   import copy
  5   import time
  6   import gevent
  7   import logging
  8   import traceback
  9   from datetime import datetime, timedelta
 10   from logging.handlers import TimedRotatingFileHandler
 11   
(Pdb) n

任何时候都可以输入命令p 变量名来查看变量

Documented commands (type help <topic>):
========================================
EOF    bt         cont      enable  jump  pp       run      unt   
a      c          continue  exit    l     q        s        until 
alias  cl         d         h       list  quit     step     up    
args   clear      debug     help    n     r        tbreak   w     
b      commands   disable   ignore  next  restart  u        whatis
break  condition  down      j       p     return   unalias  where 

pdb.set_trace()
这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点
use "c" to continue until the break point

--------- 2016-12-28 13:53:49
https://docs.python.org/2/howto/logging.html
The default level is WARNING, which means that only events of this level and above will be tracked, unless the logging package is configured to do otherwise.

Logging to a file
  logging.basicConfig(filename='example.log',level=logging.DEBUG)
If you want each run to start afresh
  logging.basicConfig(filename='example.log', filemode='w', level=logging.DEBUG)

logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)

Changing the format of displayed messages
  logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)
To display the date and time of an event, you would place ‘%(asctime)s’ in your format string:
  logging.basicConfig(format='%(asctime)s %(message)s')
The default format for date/time display (shown above) is ISO8601. If you need more control over the formatting of the date/time, provide a datefmt argument to basicConfig,
  logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%m/%d/%Y %I:%M:%S %p')
  The format of the datefmt argument is the same as supported by time.strftime().

By default, no destination is set for any logging messages. You can specify a destination (such as console or file) by using basicConfig() as in the tutorial examples. If you call the functions debug(), info(), warning(), error() and critical(), they will check to see if no destination is set; and if one is not set, they will set a destination of the console (sys.stderr) and a default format for the displayed message before delegating to the root logger to do the actual message output.

#-*- coding:utf-8 -*-
import logging
# 配置日志信息
logging.basicConfig(level=logging.DEBUG,
          format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
          datefmt='%m-%d %H:%M',
          filename='myapp.log',
          filemode='w')
# 定义一个Handler打印INFO及以上级别的日志到sys.stderr
console = logging.StreamHandler()
console.setLevel(logging.INFO)
# 设置日志打印格式
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
console.setFormatter(formatter)
# 将定义好的console日志handler添加到root logger
logging.getLogger('').addHandler(console)
logging.info('Jackdaws love my big sphinx of quartz.')
logger1 = logging.getLogger('myapp.area1')
logger2 = logging.getLogger('myapp.area2')
logger1.debug('Quick zephyrs blow, vexing daft Jim.')
logger1.info('How quickly daft jumping zebras vex.')
logger2.warning('Jail zesty vixen who grabbed pay from quack.')
logger2.error('The five boxing wizards jump quickly.')

$ tail -f myapp.log 
12-28 13:45 root         INFO     Jackdaws love my big sphinx of quartz.
12-28 13:45 myapp.area1  DEBUG    Quick zephyrs blow, vexing daft Jim.
12-28 13:45 myapp.area1  INFO     How quickly daft jumping zebras vex.
12-28 13:45 myapp.area2  WARNING  Jail zesty vixen who grabbed pay from quack.
12-28 13:45 myapp.area2  ERROR    The five boxing wizards jump quickly.

$ python logging_test.py 
root        : INFO     Jackdaws love my big sphinx of quartz.
myapp.area1 : INFO     How quickly daft jumping zebras vex.
myapp.area2 : WARNING  Jail zesty vixen who grabbed pay from quack.
myapp.area2 : ERROR    The five boxing wizards jump quickly.

通过logging.basicConfig函数对日志的输出格式及方式做相关配置

import logging

logging.basicConfig(level=logging.DEBUG,
                format='%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s %(message)s',
                datefmt='%a, %d %b %Y %H:%M:%S',
                filename='myapp.log',
                filemode='w')
    
logging.debug('This is debug message')
logging.info('This is info message')
logging.warning('This is warning message')

./myapp.log文件中内容为:
Sun, 24 May 2009 21:48:54 demo2.py[line:11] DEBUG This is debug message
Sun, 24 May 2009 21:48:54 demo2.py[line:12] INFO This is info message
Sun, 24 May 2009 21:48:54 demo2.py[line:13] WARNING This is warning message

logging.basicConfig函数各参数:
filename: 指定日志文件名
filemode: 和file函数意义相同，指定日志文件的打开模式，'w'或'a'
format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:
 %(levelno)s: 打印日志级别的数值
 %(levelname)s: 打印日志级别名称
 %(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]
 %(filename)s: 打印当前执行程序名
 %(funcName)s: 打印日志的当前函数
 %(lineno)d: 打印日志的当前行号
 %(asctime)s: 打印日志的时间
 %(thread)d: 打印线程ID
 %(threadName)s: 打印线程名称
 %(process)d: 打印进程ID
 %(message)s: 打印日志信息
datefmt: 指定时间格式，同time.strftime()
level: 设置日志级别，默认为logging.WARNING
stream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略

Handler:
  The setLevel() method, just as in logger objects, specifies the lowest severity that will be dispatched to the appropriate destination. Why are there two setLevel() methods? The level set in the logger determines which severity of messages it will pass to its handlers. The level set in each handler determines which messages that handler will send on.

#-*- coding:utf-8 -*-
import logging
# 配置日志信息
logging.basicConfig(level=logging.DEBUG,
          format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
          datefmt='%m-%d %H:%M',
          filename='myapp.log',
          filemode='w')

# 定义一个Handler打印INFO及以上级别的日志到sys.stderr
console = logging.StreamHandler()
console.setLevel(logging.INFO)
# 设置日志打印格式
formatter = logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s')
console.setFormatter(formatter)

# 将定义好的console日志handler添加到root logger
logging.getLogger('myapp').addHandler(console)
  # if set for 'myapp' or for '', which are both ancestors of myapp.xxx, then the handler will work for the decendents.

logging.info('Jackdaws love my big sphinx of quartz.')

logger1 = logging.getLogger('myapp.area1')
logger2 = logging.getLogger('myapp.area2')
logger1.debug('Quick zephyrs blow, vexing daft Jim.')
logger1.info('How quickly daft jumping zebras vex.')
logger2.warning('Jail zesty vixen who grabbed pay from quack.')
logger2.error('The five boxing wizards jump quickly.')

Logging is performed by calling methods on instances of the Logger class (hereafter called loggers). Each instance has a name, and they are conceptually arranged in a namespace hierarchy using dots (periods) as separators. For example, a logger named ‘scan’ is the parent of loggers ‘scan.text’, ‘scan.html’ and ‘scan.pdf’. Logger names can be anything you want, and indicate the area of an application in which a logged message originates.



--------------- 2016-12-28 12:26:55
notice: 
be careful not to define a module with the same name as the system module, otherwise it is hard to identify errors like:
  $ python test.py
  Traceback (most recent call last):
    File "test.py", line 10, in <module>
      from logging.handlers import TimedRotatingFileHandler
  ImportError: No module named handlers

in which case I named a local test script to logging.py.
  print the path of logging module to find out why.

--------- 2016-12-28 11:57:01
python logging:

    def _init_logger(self, cfg):
        d = cfg.get('log_path', '/tmp/')
        logger_name = 'apes.spider.%s' % self.definition.name.replace(' ', '_')
        filename = os.path.join(d, 'spider_%s.log' % self.definition.name.replace(' ', '_'))

        logger = logging.getLogger(logger_name)
        logger.setLevel(logging.DEBUG)
        handler = TimedRotatingFileHandler(filename, when='D', backupCount=7)
        handler.setLevel(logging.DEBUG)
        formatter = logging.Formatter('%(asctime)s - %(process)s - %(levelname)s - %(message)s')
        handler.setFormatter(formatter)
        logger.addHandler(handler)
        if self.offline:
            s_handler = logging.StreamHandler()
            s_handler.setLevel(logging.DEBUG)
            s_handler.setFormatter(formatter)
            logger.addHandler(s_handler)

        self.logger = logger
        return self.logger

------------ 2016-12-27 20:15:32
?? python-dev

linux发行版通常会把类库的头文件和相关的pkg-config分拆成一个单独的xxx-dev(el)包.
以python为例, 以下情况你是需要python-dev的
    你需要自己安装一个源外的python类库, 而这个类库内含需要编译的调用python api的c/c++文件
    你自己写的一个程序编译需要链接libpythonXX.(a|so)
    (注:以上不含使用ctypes/ffi或者裸dlsym方式直接调用libpython.so)
其他正常使用python或者通过安装源内的python类库的不需要python-dev.


----------- 2016-12-23 10:23:58
http://blog.csdn.net/u013418097/article/details/49512195
pymongo和python一样，属于典型的作死型语言
python3不兼容python2，pymongo在升级3后也是不向后兼容的。

在百度上能看到的教程基本都是pymongo1.x版本的
比如，连接数据库时，pymongo1.x版本是这样的
>>> import pymongo
>>> connection=pymongo.Connection('localhost',27017)
但是，pymongo3中是删掉了Connection方法，换成了另外一个，具体什么我也忘了，反正当时查了很久才发现原来这货不向后兼容
但是，问题在于，目前你能查到的关于pymongo的各种教程基本都是很古老的，初学者基本都是找博客为生，而pymongo3的教程，sorry，反正我是找不到什么的
所以，如果刚开始学的话，请不要去官网下最新的，建议使用1.x版本，练熟了再去看新的官方英文文档

--------- 2016-12-23 10:15:00
sys模块对外没有.py文件，它是内置于解释器中的，上面的代码是sys模块的源代码（c语言）。因为sys模块是整个python的基础，因此不要进行轻易的修改。 

Traceback (most recent call last):
  File "mongo.py", line 28, in <module>
    path =os.path.dirname(sys.__file__)
AttributeError: 'module' object has no attribute '__file__'


--------- 2016-12-22 15:42:28
python安装simplejson
发表于2014 年 6 月 19 日  
没有安装simplejson时报错
>>> import simplejson
Traceback (most recent call last):
  File “<stdin>”, line 1, in <module>
ImportError: No module named simplejson
simplejson是ansible一个很重要的依赖，经测试在python 2.4.3及以上版本都可以用python setup.py install 安装成功。
方法一:
yum install python-simplejson -y
方法二:
wget https://pypi.python.org/packages/source/s/simplejson/simplejson-3.5.2.tar.gz#md5=10ff73aa857b01472a51acb4848fcf8b --no-check-certificate
tar vxzf simplejson-3.5.2.tar.gz
cd simplejson-3.5.2
python setup.py install
方法三:
pip install simplejson
方法四:
easy_install simplejson

----------- 2016-12-09 18:28:24
我们知道unicode是一种编码标准，具体的实现标准可能是utf-8，utf-16，gbk ......
Python 在内部使用两个字节来存储一个unicode，使用unicode对象而不是str的好处，就是unicode方便于跨平台。
你可以用如下两种方式定义一个unicode:（在python2中）
1 s1 = u"人生苦短"
2 s2 = unicode("人生苦短", "utf-8")
python3
字符串实际就是用的unicode，直接s = "人生苦短"
py3定义bytes使用sb = b'dfja'

http://blog.163.com/jackylau_v/blog/static/1757540402011111114310418/
python在安装时，默认的编码是ascii，当程序中出现非ascii编码时，python的处理常常会报这样的错UnicodeDecodeError: 'ascii' codec can't decode byte 0x?? in position 1: ordinal not in range(128)，python没办法处理非ascii编码的，此时需要自己设置将python的默认编码，一般设置为utf8的编码格式。
  sys.getdefaultencoding()
  sys.setdefaultencoding('utf8') # 可能会报AttributeError: 'module' object has no attribute 'setdefaultencoding'的错误，执行reload(sys)，在执行以上命令就可以顺利通过。

http://www.jb51.net/article/55759.htm
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> name = '老齐'
>>> name
'\xe8\x80\x81\xe9\xbd\x90'
>>> print name
老齐

python2默认的编码是ascii，通过encode可以将对象的编码转换为指定编码格式，而decode是这个过程的逆过程。
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> name = '老齐'
>>> name
'\xe8\x80\x81\xe9\xbd\x90'
>>> print name
老齐
>>> name.decode()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> b = name.decode()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> len(name)
6
>>> b = name.decode('ascii')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 0: ordinal not in range(128)
>>> b = name.decode('utf-8')
>>> b
u'\u8001\u9f50'
>>> print b
老齐
>>> len(b)
2
>>> sys.getdefaultencoding()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'sys' is not defined
>>> import sys
>>> sys.getdefaultencoding()
'ascii'

解决办法：在出现问题的页加上如下三行即可：
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

>>> import sys
>>> reload(sys)
<module 'sys' (built-in)>
>>> sys.setdefaultencoding('utf-8')
>>> c = name.decode()
>>> print c
老齐
>>> len(c)
2

http://blog.csdn.net/lxdcyh/article/details/4018054
字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。 
decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode('gb2312')，表示将gb2312编码的字符串str1转换成unicode编码。 
encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode('gb2312')，表示将unicode编码的字符串str2转换成gb2312编码。 
因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码
因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码

代码中字符串的默认编码与代码文件本身的编码一致。 
如：s='中文'
如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件。 
如果字符串是这样定义：s=u'中文'
则该字符串的编码就被指定为unicode了，即Python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。
如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断：
isinstance(s, unicode)  #用来判断是否为unicode 
用非unicode编码形式的str来encode会报错 

$ file test.py 
test.py: Python script, UTF-8 Unicode text executable


#!encoding=utf-8
name = '老齐'
print type(name.decode('utf-8'))
  
  without the 'encoding' declaration, there will be below error:
  SyntaxError: Non-ASCII character '\xe8' in file test.py on line 7, but no encoding declared; see http://www.python.org/peps/pep-0263.html for details

both #coding=utf-8 and #!encoding=utf-8 work, without this declaration, using chinese in the .py file will fail.

    #!/usr/bin/env python  
    #coding=utf-8  
    s="中文"  
      
    if isinstance(s, unicode):  
    #s=u"中文"  
        print s.encode('gb2312')  
    else:  
    #s="中文"  
        print s.decode('utf-8').encode('gb2312')  

https://zhidao.baidu.com/question/2011216720057745028.html
python怎么知道一个字符串的编码方式
安装chardet模块
chardet文件夹放在/usr/lib/python2.4/site-packages目录下
>>> import chardet
>>> chardet.detect("我")
{'confidence': 0.505, 'encoding': 'utf-8'}


# coding=utf-8
name = '老齐'
print (name.decode('utf-8'))
print (name.decode('utf-8').encode('utf-8'))
$ python test.py
老齐
老齐

http://blog.csdn.net/chenggong2dm/article/details/7677028
#coding=utf-8
#-*- coding: utf-8 -*-
一直搞不清楚这俩头什么区别。直觉上一样。今天特意查了一下，大致明白了：
对于Python解释器来说，这两种写法一样。但是对于编辑器来讲，可能会出现识别问题。
参考：http://www.python.org/dev/peps/pep-0263/
Defining the Encoding
    Python will default to ASCII as standard encoding if no other
    encoding hints are given.
    To define a source code encoding, a magic comment must
    be placed into the source files either as first or second
    line in the file, such as:
          # coding=<encoding name>
    or (using formats recognized by popular editors)
          #!/usr/bin/python
          # -*- coding: <encoding name> -*-
    or
          #!/usr/bin/python
          # vim: set fileencoding=<encoding name> :


len(unicode) returns the number of unicodes instead of number of bytes, but len(str) e.g., when str is a utf-8 string, then the result is a length of bytes.
  this link might help: http://www.linuxidc.com/Linux/2015-02/112973.htm

http://www.jb51.net/article/55759.htm
  python中如何避免中文是乱码
  这个问题是一个具有很强操作性的问题。我这里有一个经验总结，分享一下，供参考：
  首先，提倡使用utf-8编码方案，因为它跨平台不错。
  经验一：在开头声明：
  # -*- coding: utf-8 -*-
  有朋友问我-*-有什么作用，那个就是为了好看，爱美之心人皆有，更何况程序员？当然，也可以写成：
  # coding:utf-8
  经验二：遇到字符（节）串，立刻转化为unicode，不要用str()，直接使用unicode()
  unicode_str = unicode('中文', encoding='utf-8')
  print unicode_str.encode('utf-8')
  经验三：如果对文件操作，打开文件的时候，最好用codecs.open，替代open(这个后面会讲到，先放在这里)
  import codecs
  codecs.open('filename', encoding='utf8')

------- 2016-12-09 18:14:40


由于Python源代码也是一个
文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
#!/usr/bin/env python
# -*- coding: utf-8 -*-
第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；
第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。
如果你使用Notepad++进行编辑，除了要加上# -*- coding: utf-8 -*-外，中文字符串必须是Unicode字符串

print len(u'中文')
2

print len('中文')
6


----------- 2016-12-09 18:06:22

取一个list或tuple的部分元素是非常常见的操作。
对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。


------------- 2016-12-08 13:34:50

set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。
L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。
如果第一个索引是0，还可以省略： >>> L[:3]
类似的，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片

后10个数： >>> L[-10:]

前10个数，每两个取一个： >>> L[:10:2]

所有数，每5个取一个： >>> L[::5]

甚至什么都不写，只写[:]就可以原样复制一个list：

tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple： >>> (0, 1, 2, 3, 4, 5)[:3]
(0, 1, 2)

字符串'xxx'或Unicode字符串u'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串


----------- 2016-12-07 11:34:59

python中的字符串格式函数str.format()

1 #使用str.format()函数  
2  
3 #使用'{}'占位符  
4 print('I\'m {},{}'.format('Hongten','Welcome to my space!'))  
5 >>> I'm Hongten,Welcome to my space!  
6 print('#' * 40)  
7  
8 #也可以使用'{0}','{1}'形式的占位符  
9 print('{0},I\'m {1},my E-mail is {2}'.format('Hello','Hongten','hongtenzone@foxmail.com')) 

----------- 2016-12-06 18:15:55

$ sudo python runcrawler.py stop
Stopping...
Exception SystemExit: SystemExit(0,) in <module 'threading' from '/usr/lib/python2.7/threading.pyc'> ignored
Exception SystemExit: SystemExit(0,) in <module 'threading' from '/usr/lib/python2.7/threading.pyc'> ignored
Stopped




---------- 2016-12-06 10:46:55
python以其优美的语法和方便的内置数据结构，赢得了不少程序员的亲睐。
其中有个很有用的数据结构，就是字典（dict），使用非常简单。说到遍历一个dict结构，我想大多数人都会想到 for key in dictobj 的方法，确实这个方法在大多数情况下都是适用的。
#这里初始化一个dict
>>> d = {'a':1, 'b':0, 'c':1, 'd':0}
#本意是遍历dict，发现元素的值是0的话，就删掉
>>> for k in d:
...   if d[k] == 0:
...     del(d[k])
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: dictionary changed size during iteration
#结果抛出异常了，两个0的元素，也只删掉一个。
>>> d
{'a': 1, 'c': 1, 'd': 0}

>>> d = {'a':1, 'b':0, 'c':1, 'd':0}
#d.keys() 是一个下标的数组
>>> d.keys()
['a', 'c', 'b', 'd']
#这样遍历，就没问题了，因为其实其实这里遍历的是d.keys()这个list常量。
>>> for k in d.keys():
...   if d[k] == 0:
...     del(d[k])
...
>>> d
{'a': 1, 'c': 1}
#结果也是对的

遍历dict的时候，养成使用 for k in d.keys() 的习惯。
不过，如果是多线程的话，这样就绝对安全吗？也不见得：当两个线程都取完d.keys()以后，如果两个线程都去删同一个key的话，先删的会成功，后删的那个肯定会报 KeyError ，这个看来只能通过其他方式来保证了。

for (d,x) in dict.items():
     print "key:"+d+",value:"+str(x)

for d,x in dict.items():
    print "key:"+d+",value:"+str(x)

------------ 2016-12-06 10:45:14
第一种，最常用的，通过for in遍历数组
colours = ["red","green","blue"]
for colour in colours:
    print colour
# red
# green
# blue
                                下面的方法可以先获得数组的长度，然后根据索引号遍历数组，同时输出索引号
colours = ["red","green","blue"]
for i in range(0, len(colours)):
    print i, colour[i]

---------- 2016-12-05 19:03:55
string treated as a func:

    def crawl(self):
        self.logger.info('crawl for AllInfoSpider')
        try:
            indexes = get_information_measurements()
            index_str = ",".join(indexes)
            codes = eval(self.definition.codes)()

            date = time.strftime('%Y-%m-%d',time.localtime(time.time()))
            for i in range(len(codes)):
                self.logger.info('send websocket request: %s on %s' % (self.counter, date))
                self.crawl_index_data(codes[i], date, date, index_str)
                self.logger.info('crawl finished: %s for code %s' % (self.counter, codes[i]))
                self.counter += 1
        except Exception, e:
            self.logger.info('send websocket request error: %s' % e)

--------- 2016-12-05 14:34:33
dict ops:
    def process_response(self, response, **kwargs):
        # self.logger.info('got response: %s' % response)
        temp = simplejson.JSONDecoder().decode(response)
        self.logger.info('decode type: %s' % type(temp['data']))
        result = simplejson.JSONDecoder().decode(temp['data'])
        self.logger.info('errorCode: %s' % result['errorCode'])
        for key, value in result.items():
            self.logger.info('%s: %s' % (key, type(value)))

2016-12-05 14:33:43,562 - 14831 - INFO - errorCode: -40521009
2016-12-05 14:33:43,563 - 14831 - INFO - errorCode: <type 'int'>
2016-12-05 14:33:43,563 - 14831 - INFO - codeList: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - data: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - fieldList: <type 'list'>
2016-12-05 14:33:43,563 - 14831 - INFO - timeList: <type 'list'>


list ops:



------------ 2016-12-05 11:19:53
  #类定义  
  class people:  
      #定义基本属性  
      name = ''  
      age = 0  
      #定义私有属性,私有属性在类外部无法直接进行访问  
      __weight = 0  
      #定义构造方法  
      def __init__(self,n,a,w):  
          self.name = n  
          self.age = a  
          self.__weight = w  
      def speak(self):  
          print("%s is speaking: I am %d years old" %(self.name,self.age))  
  p = people('tom',10,30)  
  p.speak()  


class A(object):    # A must be new-style class
  def __init__(self):
   print "enter A"
   print "leave A"

class B(C):     # A --> C
  def __init__(self):
   print "enter B"
   super(B, self).__init__()
   print "leave B"
　　尝试执行上面同样的代码，结果一致，但修改的代码只有一处，把代码的维护量降到最低，是一个不错的用法。因此在我们的开发过程中，super关键字被大量使用，而且一直表现良好。
　　在我们的印象中，对于super(B, self).__init__()是这样理解的：super(B, self)首先找到B的父类（就是类A），然后把类B的对象self转换为类A的对象（通过某种方式，一直没有考究是什么方式，惭愧），然后“被转换”的类A对象调用自己的__init__函数。考虑到super中只有指明子类的机制，因此，在多继承的类定义中，通常我们保留使用类似代码段1的方法。

------------ 2016-12-05 10:59:31
Python pass是空语句，是为了保持程序结构的完整性。
pass 不做任何事情，一般用做占位语句。

------------- 2016-12-03 18:30:51
一个包是一个带有特殊文件 __init__.py 的目录。__init__.py 文件定义了包的属性和方法。其实它可以什么也不定义；可以只是一个空文件，但是必须存在。如果 __init__.py 不存在，这个目录就仅仅是一个目录，而不是一个包，它就不能被导入或者包含其它的模块和嵌套包。

__init__.py 文件会在导入时被执行。

__init__.py 中还有一个重要的变量，叫做 __all__。我们有时会使出一招“全部导入”，也就是这样：
from PackageName import *
这时 import 就会把注册在包 __init__.py 文件中 __all__ 列表中的子模块和子包导入到当前作用域中来。比如：
#文件 __init__.py
__all__ = ["Module1", "Module2", "subPackage1", "subPackage2"]
测试：
>>> from Package1 import *


--------- 2016-12-03 18:08:59
object 对象是所有内建类型及 new-style class 的祖先。 object 对象定义了一系列特殊方法(参见 5.3 节后半部分)实现所有对象的默认行为。
__new__, __init__ 方法
你可以创建 object 的直接子类，静态方法 __new__()用来创建类的实例， 实例的 __init__() 方法用来初始化自己。 默认的 __init__() 方法会忽略你传递过来的任何参数。

Python中所有的类成员（包括数据成员）都是 公共的 ，所有的方法都是 有效的 。
只有一个例外：如果你使用的数据成员名称以 双下划线前缀 比如__privatevar，Python的名称管理体系会有效地把它作为私有变量。
记住这只是一个惯例，并不是Python所要求的（与双下划线前缀不同）。

python当函数的参数不确定时，可以使用*args和**kwargs。*args没有key值，**kwargs有key值,下面看例子
#coding=utf8
__author__ = 'Administrator'
# 当函数的参数不确定时，可以使用*args和**kwargs。*args没有key值，**kwargs有key值
def fun_var_args(farg, *args):
    print 'args:', farg
    for value in args:
        print 'another arg:',value
# *args可以当作可容纳多个变量组成的list或tuple
fun_var_args(1, 'two', 3, None)
#args: 1
#another arg: two
#another arg: 3
#another arg: None
def fun_var_kwargs(farg, **kwargs):
    print 'args:',farg
    for key in kwargs:
        print 'another keyword arg:%s:%s' % (key, kwargs[key])

--------- 2016-11-21 17:02:24
python字符串转json对象，需要使用json模块的loads函数
import json
          jo = json.loads(result)
            print len(jo['data'])
            for info in infos:
                print jo['data'][0]['secID']

$ python tushare_test.py 
/data/v1/api/equity/getEqu.json?field=&ticker=000001&secID=&equTypeCD=&listStatusCD=
{"retCode":1,"retMsg":"Success","data":[{"secID":"000001.XSHE","ticker":"000001","exchangeCD":"XSHE","ListSectorCD":1,"ListSector":"主板","transCurrCD":"CNY","secShortName":"平安银行","secFullName":"平安银行股份有限公司","listStatusCD":"L","listDate":"1991-04-03","equTypeCD":"A","equType":"沪深A股","exCountryCD":"CHN","partyID":2,"totalShares":17170411400,"nonrestFloatShares":14631180400,"nonrestfloatA":14631180400,"officeAddr":"广东省深圳市罗湖区深南东路5047号","primeOperating":"(一)吸收公众存款；(二)发放短期、中期和长期贷款；(三)办理国内外结算；(四)办理票据承兑与贴现；(五)发行金融债券；(六)代理发行、代理兑付、承销政府债券；(七)买卖政府债券、金融债券；(八)从事同业拆借；(九)买卖、代理买卖外汇；(十)从事银行卡业务；(十一)提供信用证服务及担保；(十二)代理收付款项及代理保险业务；(十三)提供保管箱服务；(十四)结汇、售汇业务；(十五)离岸银行业务；(十六)资产托管业务；(十七)办理黄金业务；(十八)财务顾问、资信调查、咨询、见证业务；(十九)经有关监管机构批准的其他业务。","endDate":"2016-09-30","TShEquity":198228000000}]}

--------- 2016-11-21 14:42:19

$ python tushare_information.py 
/usr/lib/python2.7/dist-packages/pkg_resources.py:1031: UserWarning: /home/kidd/.python-eggs is writable by group/others and vulnerable to attack when used with get_resource_filename. Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
  warnings.warn(msg, UserWarning)
/usr/local/lib/python2.7/dist-packages/tushare/stock/classifying.py:93: FutureWarning: sort(columns=....) is deprecated, use sort_values(by=.....)
  df = df.sort('area').reset_index(drop=True)
got 2997 rows
Traceback (most recent call last):
  File "tushare_information.py", line 55, in <module>
    output.write(result.ix[i]['code'] + ': ' + result.ix[i]['name'] + '\n')
  File "/usr/lib/python2.7/codecs.py", line 688, in write
    return self.writer.write(data)
  File "/usr/lib/python2.7/codecs.py", line 351, in write
    data, consumed = self.encode(object, self.errors)
  File "/usr/lib/python2.7/encodings/utf_8_sig.py", line 82, in encode
    return encode(input, errors)
  File "/usr/lib/python2.7/encodings/utf_8_sig.py", line 15, in encode
    return (codecs.BOM_UTF8 + codecs.utf_8_encode(input, errors)[0], len(input))
UnicodeDecodeError: 'ascii' codec can't decode byte 0xe8 in position 8: ordinal not in range(128)

http://stackoverflow.com/questions/9644099/python-ascii-codec-cant-decode-byte
  output.write(result.ix[i]['code'] + ': ' + result.ix[i]['name'].decode('utf-8') + ' and name: ' + result.ix[i][returned_class_name].decode('utf-8') + '\n')


------------- 2016-11-21 12:20:03
1   import a_module
2   print a_module.__file__

上述代码将范围 .pyc 文件被加载的路径，如果需要跨平台解决方案，可用下面代码：
1   import os
2   path =os.path.dirname(amodule.__file__)


------------- 2016-11-17 20:25:51
import pymongo
import time
import datetime
import urllib2
from WindPy import *

print time.mktime(datetime.datetime.now().timetuple())

=> 
D:\abc\samples>python t.pyp
Traceback (most recent call last):
  File "t.pyp", line 8, in <module>
    print time.mktime(datetime.datetime.now().timetuple())
AttributeError: type object 'datetime.time' has no attribute 'mktime'

but there is no such error after putting "from WindPy import *" at the front.


-------- 2016-11-17 10:06:38
Traceback (most recent call last):
  File "/home/kidd/workspace/python/windpy/crawl_performance.py", line 17, in <module>
    for code in codes:
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 904, in next
    if len(self.__data) or self._refresh():
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 865, in _refresh
    limit, self.__id))
  File "/usr/lib/python2.7/dist-packages/pymongo/cursor.py", line 800, in __send_message
    self.__uuid_subtype)
  File "/usr/lib/python2.7/dist-packages/pymongo/helpers.py", line 94, in _unpack_response
    cursor_id)
pymongo.errors.OperationFailure: cursor id '55721940917' not valid at server

do not keep cursor all the time:
  code_col = info_db.wind_wset
  bak_codes = code_col.find()

----------- 2016-11-09 16:22:52
$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> print sys.path
['', '/usr/local/lib/python2.7/dist-packages/rospkg-1.0.39-py2.7.egg', '/usr/local/lib/python2.7/dist-packages/MySQL_python-1.2.5-py2.7-linux-x86_64.egg', '/usr/lib/python2.7', '/usr/lib/python2.7/plat-x86_64-linux-gnu', '/usr/lib/python2.7/lib-tk', '/usr/lib/python2.7/lib-old', '/usr/lib/python2.7/lib-dynload', '/usr/local/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages', '/usr/lib/python2.7/dist-packages/PILcompat', '/usr/lib/python2.7/dist-packages/gtk-2.0', '/usr/lib/pymodules/python2.7', '/usr/lib/python2.7/dist-packages/ubuntu-sso-client', '/usr/lib/python2.7/dist-packages/wx-2.8-gtk2-unicode']

$ pip install pymongo
Requirement already satisfied (use --upgrade to upgrade): pymongo in /usr/lib/python2.7/dist-packages


------------ 2016-11-09 11:12:02
def test():
  exit()

test()
print "Good bye!" # this line will not be output!!!

-------- 2016-11-04 11:15:05
python 执行时是如何查找包和模块的 
python 执行一个文件，无论执行的方式是绝对路径还是相对路径，解释器都会把文件所在的目录加入到系统查找路径中，也就是 sys.path 这个 list 中，而 sys.path 又是由系统的 python 环境变量决定的。 


---------- 2016-11-04 10:26:53
1. 如果模块是被导入，__name__的值为模块名字
2. 如果模块是被直接执行，__name__的值为’__main__’

Python中比较特别,导入文件夹下的py文件,则这个目录下必须要有一个__init__.py文件才可
Python的import包含文件功能就跟PHP的include类似，但更确切的说应该更像是PHP中的require，因为Python里的import只要目标不存在就报错程序无法往下执行。要包含目录里的文件，PHP中只需要给对路径就OK。Python中则不同，
提示找不到这个模块的名字 dir.b 。通过查找官方文档，发现要包含目录下的文件时需要在目录下声明一个__init__.py文件，即使这个文件是空的也可以。当然这个文件也可以初始一些数据。
__init__.py seems not necessary if the module is under the same directory.

~/software/python/test
$ tree
.
├── test.py
└── tools
    ├── __init__.py
    ├── __init__.pyc
    ├── tools.py
    └── tools.pyc


---------- 2016-11-04 10:38:09 
pyc
https://www.zhihu.com/question/30296617
        A program doesn't run any faster when it is read from a ‘.pyc’ or ‘.pyo’ file than when it is read from a ‘.py’ file; the only thing that's faster about ‘.pyc’ or ‘.pyo’files is the speed with which they are loaded.
        When a script is run by giving its name on the command line, the bytecode for the script is never written to a ‘.pyc’ or ‘.pyo’ file. Thus, the startup time of a script may be reduced by moving most of its code to a module and having a small bootstrap script that imports that module. It is also possible to name a ‘.pyc’ or ‘.pyo’file directly on the command line.

在你 import 别的 py 文件时，那个 py 文件会被存一份 pyc 加速下次装载。而主文件因为只需要装载一次就没有存 pyc，你可以写两个 a.py 和 b.py，一个 import 另一个试试看。 

当我们运行python文件程序的时候，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。因此总的来说，它具有以下三条特性

    源码距离底层更远（根据官方文档的解释。不说，你们也感觉得到）(。・`ω´・)
    运行时都需要生成字节码，交由虚拟机执行。（你们问我虚拟机在哪儿？！你们也不看看各自都是用什么软件执行的！没错，就是解释器，别和我说是IDLE啊。虚拟机具体实现了由switch-case语句构成的框架函数PyEval_EvalFrameEx，刚刚说的字节码就是这货执行的）
    每次执行脚本，虚拟机总要多出加载和链接的流程。（所以呢，相比于编译型语言就有点慢了。这与“有丝分裂间期”一样，准备东西也要花时间啊！）


毕竟对于比较大的项目，要将PyCodeObject写回硬盘也是不可避免地要花些时间的，而且它又不知道你是不是也就只执行一次，之后就对刚刚跑完的脚本“弃之不顾”了呢。不过，它其实也有贴心的一面。比如，

    若你在命令行直接输入“python path/to/projectDir”（假设projectDir目录含有“__main__.py”文件，以及其他将要调用的模块），那么程序运行结束后便自动为当前目录下所有的脚本生成字节码文件，并保存于本地新文件夹__pycache__当中。（这也有可能是IDE写小项目时自动生成.pyc文件的原因，不过问题描述略微暧昧。详情参见上面知乎问题板块）

或者是，在命令行输入“python path/to/projectDir/__main__.py”，则生成除__main__.py外脚本的字节码文件。不过总的来说，上述这两种行为都大大缩短了项目运行前的准备时间（毕竟分工明确的程序，规模应该不会太小，复用率也不会太低。除非吃饱了撑着，搞出这么多事情(Θ皿Θメ)）
模块在每次导入前总会检查其字节码文件的修改时间是否与自身的一致。若是则直接从该字节码文件读取内容，否则源模块重新导入，并在最后生成同名文件覆盖当前已有的字节码，从而完成内容的更新（详见import.py）。

http://www.tuicool.com/articles/iYRfe2
如果你需要 python 讲一个文件夹作为 package 执行，那么这个文件夹中必须包含一个名为 __main__.py 的文件，当执行 python -m hhlb 或者 python hhlb 的时候，这个文件中的代码都会被执行。

---------- 2016-11-01 14:36:14

    sudo apt-get install 安装的package存放在 /usr/lib/python2.7/dist-packages目录中
    pip 或者 easy_install安装的package存放在/usr/local/lib/python2.7/dist-packages目录中
    手动从源代码安装的package存放在site-packages目录中

----------- 2016-11-02 10:13:52

在Ubuntu14.04上，建议通过下面的方法安装，这是一种通用的方法，也适用于Windows，当然在Windows下

手动下载下来就行了

wget https://bootstrap.pypa.io/get-pip.py  --no-check-certificate [vpn is necessary]
sudo python get-pip.py

如果在Ubuntu14.04上你用sudo apt-get install python-pip下载安装，在使用时有可能出现下面的问题
复制代码

root@ubt:~# pip 
Traceback (most recent call last):
  File "/usr/bin/pip", line 9, in <module>
    load_entry_point('pip==1.5.4', 'console_scripts', 'pip')()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 351, in load_entry_point
    return get_distribution(dist).load_entry_point(group, name)
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2363, in load_entry_point
    return ep.load()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2088, in load
    entry = __import__(self.module_name, globals(),globals(), ['__name__'])
  File "/usr/lib/python2.7/dist-packages/pip/__init__.py", line 11, in <module>
    from pip.vcs import git, mercurial, subversion, bazaar  # noqa
  File "/usr/lib/python2.7/dist-packages/pip/vcs/mercurial.py", line 9, in <module>
    from pip.download import path_to_url
  File "/usr/lib/python2.7/dist-packages/pip/download.py", line 25, in <module>
    from requests.compat import IncompleteRead
ImportError: cannot import name IncompleteRead

复制代码

这是因为通过apt-get安装的pip版本太老了，老的pip版本依赖requests.compat.IncompleteRead，而在2.4.0版本的requests中已经移除了

requests.compat.IncompleteRead，解决方法是先卸载pip（命令为sudo apt-get remove python-pip），然后再用上面的方法重新安装。

有时，还会遇到下面的SSL错误

/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.

安装下面几个包

pip install pyopenssl ndg-httpsclient pyasn1

如果还有问题，再安装下面的包

sudo apt-get install libffi-dev libssl-dev

 

安装完后，测试一下吧，发现不能识别pip这个命令，额，我也不知道怎么回事，解决办法是在/usr/bin目录下建一个软链接，指向到/usr/local/bin/pip
复制代码

njsqrt3@temp-test2:~$ pip
-bash: /usr/bin/pip: No such file or directory        # $PATH的值包含/usr/bin
njsqrt3@temp-test2:~$ which pip
/usr/local/bin/pip                                    # $PATH的值包含/usr/local/bin
njsqrt3@temp-test2:~$ 
njsqrt3@temp-test2:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
njsqrt3@temp-test2:~$

------------------- 2016-11-02 10:16:14
$ sudo python get-pip.py 
The directory '/home/kidd/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
The directory '/home/kidd/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
Collecting pip
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  Downloading pip-8.1.2-py2.py3-none-any.whl (1.2MB)
    100% |████████████████████████████████| 1.2MB 763kB/s 
Collecting wheel
  Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB)
    100% |████████████████████████████████| 71kB 1.2MB/s 
Installing collected packages: pip, wheel
Successfully installed pip-8.1.2 wheel-0.29.0
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.

---------- 2017-02-08 13:37:42
cprint
# coding=u8

'''
库名：cprint
函数名：cprint()
功能：格式化输出list/set/tuple/dict等复杂类型对象，支持中文正常显示。
 '''

import sys

def __create_spaces(lvl):
    spaces = ''
    tab = '    '
    for i in range(lvl-1):
        spaces = spaces + tab
    return spaces

def __print(obj,end='\n'):
    if isinstance(obj,unicode):
        obj = obj.encode('u8')
    if isinstance(obj,str):
        sys.stdout.write(obj+end)
    else:
        print(obj),
        sys.stdout.write(end)

def cprint(obj,lvl=0,indict=False,islast=True):
    lvl = lvl + 1 
    spaces = __create_spaces(lvl)
    index = 0

    if isinstance(obj,list):
        if not indict:
            __print(spaces,end='')
        __print('[')
        for item in obj:
            if index+1 < len(obj):
                cprint(item,lvl,islast=False)
            else:
                cprint(item,lvl)
            index = index + 1
        __print(spaces + ']',end='')
        if islast:
            __print('')
        else:
            __print(',')

    elif isinstance(obj,tuple):
        if not indict:
            __print(spaces,end='')
        __print('(')
        for item in obj:
            if index+1 < len(obj):
                cprint(item,lvl,islast=False)
            else:
                cprint(item,lvl)
            index = index + 1
        __print(spaces + ')',end='')
        if islast:
            __print('')
        else:
            __print(',')

    elif isinstance(obj,set):
        if not indict:
            __print(spaces,end='')
        __print('set(')
        for item in obj:
            if index+1 < len(obj):
                cprint(item,lvl,islast=False)
            else:
                cprint(item,lvl)
            index = index + 1
        __print(spaces + ')',end='')
        if islast:
            __print('')
        else:
            __print(',')

    elif isinstance(obj,dict):
        __print(spaces + '{')
        for key in obj:
            __print(__create_spaces(lvl+1)+str(key) + ': ',end='')
            if index+1 < len(obj):
                cprint(obj[key],lvl,indict=True,islast=False)
            else:
                cprint(obj[key],lvl,indict=True)
            index = index + 1
        __print(spaces + '}',end='')
        if islast:
            __print('')
        else:
            __print(',')

    else:
        if not indict:
            __print(spaces,end='')
        __print(obj,end='')
        if islast:
            __print('')
        else:
            __print(',')



if __name__ == '__main__':
    obj1 = {
        'data':[
            {
            'data_id':'1',
            'content':'西红柿'
            },
            {
            'data_id':'2',
            'content':'胡萝卜'
            }
        ],
        'name':'蔬菜',
        'id':1,
    }
    print(obj1)
    print('\n')
    import pprint
    pprint.pprint(obj1)
    print('\n')
    cprint(obj1)

----------- 2017-03-13 18:09:08
python web

WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return '<h1>Hello, web!</h1>'
上面的application()函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：

environ：一个包含所有HTTP请求信息的dict对象；

start_response：一个发送HTTP响应的函数。

在application()函数中，调用：

start_response('200 OK', [('Content-Type', 'text/html')])
就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次start_response()函数。start_response()函数接收两个参数，一个是HTTP响应码，一个是一组list表示的HTTP Header，每个Header用一个包含两个str的tuple表示。

通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。

然后，函数的返回值'<h1>Hello, web!</h1>'将作为HTTP响应的Body发送给浏览器。

有了WSGI，我们关心的就是如何从environ这个dict对象拿到HTTP请求信息，然后构造HTML，通过start_response()发送Header，最后返回Body。

整个application()函数本身没有涉及到任何解析HTTP的部分，也就是说，底层代码不需要我们自己编写，我们只负责在更高层次上考虑如何响应请求就可以了。

不过，等等，这个application()函数怎么调用？如果我们自己调用，两个参数environ和start_response我们没法提供，返回的str也没法发给浏览器。

所以application()函数必须由WSGI服务器来调用。有很多符合WSGI规范的服务器，我们可以挑选一个来用。但是现在，我们只想尽快测试一下我们编写的application()函数真的可以把HTML输出到浏览器，所以，要赶紧找一个最简单的WSGI服务器，把我们的Web应用程序跑起来。

好消息是Python内置了一个WSGI服务器，这个模块叫wsgiref，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。

运行WSGI服务

我们先编写hello.py，实现Web应用程序的WSGI处理函数：

# hello.py

def application(environ, start_response):
    start_response('200 OK', [('Content-Type', 'text/html')])
    return '<h1>Hello, web!</h1>'
然后，再编写一个server.py，负责启动WSGI服务器，加载application()函数：

# server.py
# 从wsgiref模块导入:
from wsgiref.simple_server import make_server
# 导入我们自己编写的application函数:
from hello import application

# 创建一个服务器，IP地址为空，端口是8000，处理函数是application:
httpd = make_server('', 8000, application)
print "Serving HTTP on port 8000..."
# 开始监听HTTP请求:
httpd.serve_forever()

sample run:
    ~/workspace/python/scipy/wsgi
    $ python server.py 
    Serving HTTP on port 8000...
    10.12.0.11 - - [13/Mar/2017 18:08:34] "GET / HTTP/1.1" 200 20
    10.12.0.11 - - [13/Mar/2017 18:08:35] "GET /favicon.ico HTTP/1.1" 200 20

----------- 2017-03-13 20:32:50
sudo apt-get install python-flask

pip install flask [failed]
easy_install flask [failed]

#!encoding=utf-8

from flask import Flask
from flask import request

app = Flask(__name__)

@app.route('/', methods=['GET', 'POST'])
def home():
    return '<h1>Home</h1>'

@app.route('/signin', methods=['GET'])
def signin_form():
    return '''<form action="/signin" method="post">
              <p><input name="username"></p>
              <p><input name="password" type="password"></p>
              <p><button type="submit">Sign In</button></p>
              </form>'''

@app.route('/signin', methods=['POST'])
def signin():
    # 需要从request对象读取表单内容：
    if request.form['username']=='admin' and request.form['password']=='password':
        return '<h3>Hello, admin!</h3>'
    return '<h3>Bad username or password.</h3>'

if __name__ == '__main__':
    app.run()

除了Flask，常见的Python Web框架还有：
Django：全能型Web框架；
web.py：一个小巧的Web框架；
Bottle：和Flask类似的Web框架；
Tornado：Facebook的开源异步Web框架。






-------- 2016-11-04 11:15:05
python 执行时是如何查找包和模块的 
python 执行一个文件，无论执行的方式是绝对路径还是相对路径，解释器都会把文件所在的目录加入到系统查找路径中，也就是 sys.path 这个 list 中，而 sys.path 又是由系统的 python 环境变量决定的。 


---------- 2016-11-04 10:26:53
1. 如果模块是被导入，__name__的值为模块名字
2. 如果模块是被直接执行，__name__的值为’__main__’

Python中比较特别,导入文件夹下的py文件,则这个目录下必须要有一个__init__.py文件才可
Python的import包含文件功能就跟PHP的include类似，但更确切的说应该更像是PHP中的require，因为Python里的import只要目标不存在就报错程序无法往下执行。要包含目录里的文件，PHP中只需要给对路径就OK。Python中则不同，
提示找不到这个模块的名字 dir.b 。通过查找官方文档，发现要包含目录下的文件时需要在目录下声明一个__init__.py文件，即使这个文件是空的也可以。当然这个文件也可以初始一些数据。
__init__.py seems not necessary if the module is under the same directory.

~/software/python/test
$ tree
.
├── test.py
└── tools
    ├── __init__.py
    ├── __init__.pyc
    ├── tools.py
    └── tools.pyc


---------- 2016-11-04 10:38:09 
pyc
https://www.zhihu.com/question/30296617
        A program doesn't run any faster when it is read from a ‘.pyc’ or ‘.pyo’ file than when it is read from a ‘.py’ file; the only thing that's faster about ‘.pyc’ or ‘.pyo’files is the speed with which they are loaded.
        When a script is run by giving its name on the command line, the bytecode for the script is never written to a ‘.pyc’ or ‘.pyo’ file. Thus, the startup time of a script may be reduced by moving most of its code to a module and having a small bootstrap script that imports that module. It is also possible to name a ‘.pyc’ or ‘.pyo’file directly on the command line.

在你 import 别的 py 文件时，那个 py 文件会被存一份 pyc 加速下次装载。而主文件因为只需要装载一次就没有存 pyc，你可以写两个 a.py 和 b.py，一个 import 另一个试试看。 

当我们运行python文件程序的时候，Python解释器将源码转换为字节码，然后再由解释器来执行这些字节码。因此总的来说，它具有以下三条特性

    源码距离底层更远（根据官方文档的解释。不说，你们也感觉得到）(。・`ω´・)
    运行时都需要生成字节码，交由虚拟机执行。（你们问我虚拟机在哪儿？！你们也不看看各自都是用什么软件执行的！没错，就是解释器，别和我说是IDLE啊。虚拟机具体实现了由switch-case语句构成的框架函数PyEval_EvalFrameEx，刚刚说的字节码就是这货执行的）
    每次执行脚本，虚拟机总要多出加载和链接的流程。（所以呢，相比于编译型语言就有点慢了。这与“有丝分裂间期”一样，准备东西也要花时间啊！）


毕竟对于比较大的项目，要将PyCodeObject写回硬盘也是不可避免地要花些时间的，而且它又不知道你是不是也就只执行一次，之后就对刚刚跑完的脚本“弃之不顾”了呢。不过，它其实也有贴心的一面。比如，

    若你在命令行直接输入“python path/to/projectDir”（假设projectDir目录含有“__main__.py”文件，以及其他将要调用的模块），那么程序运行结束后便自动为当前目录下所有的脚本生成字节码文件，并保存于本地新文件夹__pycache__当中。（这也有可能是IDE写小项目时自动生成.pyc文件的原因，不过问题描述略微暧昧。详情参见上面知乎问题板块）

或者是，在命令行输入“python path/to/projectDir/__main__.py”，则生成除__main__.py外脚本的字节码文件。不过总的来说，上述这两种行为都大大缩短了项目运行前的准备时间（毕竟分工明确的程序，规模应该不会太小，复用率也不会太低。除非吃饱了撑着，搞出这么多事情(Θ皿Θメ)）
模块在每次导入前总会检查其字节码文件的修改时间是否与自身的一致。若是则直接从该字节码文件读取内容，否则源模块重新导入，并在最后生成同名文件覆盖当前已有的字节码，从而完成内容的更新（详见import.py）。

http://www.tuicool.com/articles/iYRfe2
如果你需要 python 讲一个文件夹作为 package 执行，那么这个文件夹中必须包含一个名为 __main__.py 的文件，当执行 python -m hhlb 或者 python hhlb 的时候，这个文件中的代码都会被执行。

---------- 2016-11-01 14:36:14

    sudo apt-get install 安装的package存放在 /usr/lib/python2.7/dist-packages目录中
    pip 或者 easy_install安装的package存放在/usr/local/lib/python2.7/dist-packages目录中
    手动从源代码安装的package存放在site-packages目录中

----------- 2016-11-02 10:13:52

在Ubuntu14.04上，建议通过下面的方法安装，这是一种通用的方法，也适用于Windows，当然在Windows下

手动下载下来就行了

wget https://bootstrap.pypa.io/get-pip.py  --no-check-certificate [vpn is necessary]
sudo python get-pip.py

如果在Ubuntu14.04上你用sudo apt-get install python-pip下载安装，在使用时有可能出现下面的问题
复制代码

root@ubt:~# pip 
Traceback (most recent call last):
  File "/usr/bin/pip", line 9, in <module>
    load_entry_point('pip==1.5.4', 'console_scripts', 'pip')()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 351, in load_entry_point
    return get_distribution(dist).load_entry_point(group, name)
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2363, in load_entry_point
    return ep.load()
  File "/usr/lib/python2.7/dist-packages/pkg_resources.py", line 2088, in load
    entry = __import__(self.module_name, globals(),globals(), ['__name__'])
  File "/usr/lib/python2.7/dist-packages/pip/__init__.py", line 11, in <module>
    from pip.vcs import git, mercurial, subversion, bazaar  # noqa
  File "/usr/lib/python2.7/dist-packages/pip/vcs/mercurial.py", line 9, in <module>
    from pip.download import path_to_url
  File "/usr/lib/python2.7/dist-packages/pip/download.py", line 25, in <module>
    from requests.compat import IncompleteRead
ImportError: cannot import name IncompleteRead

复制代码

这是因为通过apt-get安装的pip版本太老了，老的pip版本依赖requests.compat.IncompleteRead，而在2.4.0版本的requests中已经移除了

requests.compat.IncompleteRead，解决方法是先卸载pip（命令为sudo apt-get remove python-pip），然后再用上面的方法重新安装。

有时，还会遇到下面的SSL错误

/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpFlFxFp/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.

安装下面几个包

pip install pyopenssl ndg-httpsclient pyasn1

如果还有问题，再安装下面的包

sudo apt-get install libffi-dev libssl-dev

 

安装完后，测试一下吧，发现不能识别pip这个命令，额，我也不知道怎么回事，解决办法是在/usr/bin目录下建一个软链接，指向到/usr/local/bin/pip
复制代码

njsqrt3@temp-test2:~$ pip
-bash: /usr/bin/pip: No such file or directory        # $PATH的值包含/usr/bin
njsqrt3@temp-test2:~$ which pip
/usr/local/bin/pip                                    # $PATH的值包含/usr/local/bin
njsqrt3@temp-test2:~$ 
njsqrt3@temp-test2:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games
njsqrt3@temp-test2:~$

------------------- 2016-11-02 10:16:14
$ sudo python get-pip.py 
The directory '/home/kidd/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
The directory '/home/kidd/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.
Collecting pip
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:318: SNIMissingWarning: An HTTPS request has been made, but the SNI (Subject Name Indication) extension to TLS is not available on this platform. This may cause the server to present an incorrect TLS certificate, which can cause validation failures. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#snimissingwarning.
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
  Downloading pip-8.1.2-py2.py3-none-any.whl (1.2MB)
    100% |████████████████████████████████| 1.2MB 763kB/s 
Collecting wheel
  Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB)
    100% |████████████████████████████████| 71kB 1.2MB/s 
Installing collected packages: pip, wheel
Successfully installed pip-8.1.2 wheel-0.29.0
/tmp/tmpHWvX8Y/pip.zip/pip/_vendor/requests/packages/urllib3/util/ssl_.py:122: InsecurePlatformWarning: A true SSLContext object is not available. This prevents urllib3 from configuring SSL appropriately and may cause certain SSL connections to fail. You can upgrade to a newer version of Python to solve this. For more information, see https://urllib3.readthedocs.org/en/latest/security.html#insecureplatformwarning.
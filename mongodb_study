
shell cmds:
  show dbs
  use db_name
  db.stats()


----------- 2016-11-29 20:31:04
BSON是由10gen开发的一个数据格式，目前主要用于MongoDB中，是MongoDB的数据存储格式。BSON基于JSON格式，选择JSON进行改造的原因主要是JSON的通用性及JSON的schemaless的特性。
BSON主要会实现以下三点目标：
1.更快的遍历速度
对JSON格式来说，太大的JSON结构会导致数据遍历非常慢。在JSON中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配，而BSON对JSON的一大改进就是，它会将JSON的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。
2.操作更简易
对JSON来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。而使用BSON，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。当然，在MongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。
3.增加了额外的数据类型
JSON是一个很方便的数据交换格式，但是其类型比较有限。BSON在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。大大减少了计算开销和数据大小。
当然，在有的时候，BSON相对JSON来说也并没有空间上的优势，比如对{“field”:7}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位）
目前在10gen的努力下，BSON已经有了针对多种语言的编码解码包。并且都是Apache 2 license下开源的。并且还在随着MongoDB进一步地发展。

MongoDB使用BSON做为文档数据存储和网络传输格式

http://suo.iteye.com/blog/1073243
按照官方的说法，MongoDB是一种可扩展的高性能的开源的面向文档（document-oriented ）的数据库，采用C++开发。
    面向文档，那么什么是文档呢？很明显这不是我们常见的word文档。这里说的文档，是一种可以嵌套的数据集合。从关系数据库的范式的概念来说，嵌套是明显的反范式设计。范式设计的好处是消除了依赖，但是增加了关联，查询需要通过关联两张或者多张表来获得所需要的全部数据，但是更改操作是原子的，只需要修改一个地方即可。反范式则是增加了数据冗余来提升查询性能，但更新操作可能需要更新冗余的多处数据，需要注意一致性的问题。


---------- 2016-11-28 14:34:03


mongodb现有的数据是这样
    {  
      "_id" : ObjectId("4ec0b2a4ecb31ca1968000fd"),  
      "id" : 1001,  
      "singer" : "刘德华",  
      "someReview" : [{  
          "user" : "dong",  
          "text" : "不好听"  
        }, {  
          "user" : "wan",  
          "text" : "打酱油"  
        }, {  
          "user" : "wan",  
          "text" : "真的挺不错，一直很喜欢刘德华"  
        }]  
    }  
 查出的结果是
    {  
          "user" : "wan",  
          "text" : "打酱油"  
    }      
 请问改怎么查？？谢谢

楼主，你好，假如你的表(collection)叫test，可以这样做，
db.test.find({"someReview.user":"wan"},{"someReview.user":1,"someReview.text":1})
第一个参数是查询条件，第二参数是要查询的字段

db.things.find( { someReview.user: "wan" } );

> use test
switched to db test
> db.test.insert([{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}])
> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
> db.test.insert({[{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}]})
Mon Nov 28 14:41:07.671 SyntaxError: Unexpected token [
> db.test.insert({array : [{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}]})
> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }
> db.test.find({array.name : kidd})
Mon Nov 28 14:41:49.518 SyntaxError: Unexpected token .
> db.test.find({array.name : 'kidd'})
Mon Nov 28 14:41:54.374 SyntaxError: Unexpected token .
> db.test.find({'array.name' : 'kidd'})
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }

> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }
{ "_id" : ObjectId("583bd37867e7f31d19e6f509"), "fruits" : [  "apple",  "banana",  "pear" ] }
> db.test.find({fruits : 'banana'})
{ "_id" : ObjectId("583bd37867e7f31d19e6f509"), "fruits" : [  "apple",  "banana",  "pear" ] }

----------- 2016-11-21 14:47:10
db.tushare_information.update({}, {$unset:{'area' : ''}}, {multi: true})
删除表中，所有的字段

---------- 2016-11-21 12:28:51
$ python tushare_information.py 
/usr/lib/python2.7/dist-packages/pkg_resources.py:1031: UserWarning: /home/kidd/.python-eggs is writable by group/others and vulnerable to attack when used with get_resource_filename. Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
  warnings.warn(msg, UserWarning)
[Getting data:]#################################################got 2847 rows
<type 'dict'>
{u'updatedExisting': True, u'connectionId': 11, u'ok': 1.0, u'err': None, u'n': 1}


------------ 2016-11-17 18:50:20
use pretty() to format:
  db.performance.find().pretty()

------------- 2016-11-17 14:48:40
mongodb cursor id not valid error是一个超时错误。
当使用for  c  in  col.find()时，数据库会一次性返回很多数据，如果处理这些数据的时间超过10分钟，一直没有像数据库获取后续数据，则会出现上述错误。
 
解决方案：
取消timeout限制，在结束遍历后close()游标。
cursor = coll.find(timeout=False)
for c in cursor:
    ...
    ...
cursor.close()
 
 
其他方案：
上面那个方案是我使用后成功的。还有几种方案，我尝试了一下，无效，不知道为什么。
解决方案2：
用batch_size()限制一次获取的数据量
for c in col.find().batch_size(20):
    ...
 
解决方案3：
用no_cursor_timeout参数去掉时间限制。注意后面要close()游标。
cursor=db.images.find(no_cursor_timeout=True)
for i in cursor:
   .....
   .....
cursor.close()

-------- 2016-11-17 12:55:01
export and import
http://chenzhou123520.iteye.com/blog/1641319

$ mongoexport -h 10.12.6.6 -d apes -c measurements -o ~/tmp/measurements.dat
connected to: 10.12.6.6
exported 202 records

$ mongoimport -h 10.12.0.36 -d apes -c measurements ~/tmp/measurements.dat 
connected to: 10.12.0.36
Thu Nov 17 12:56:08.134 check 9 202
Thu Nov 17 12:56:08.137 imported 202 objects


-------------- 2016-11-16 11:03:44
search

db.measurements.find({"path" : /预测评级/ })




------------ 2016-11-15 13:34:15
$ python loadinfo.py 
None
kidd@kidd-OptiPlex-9020:
~/workspace/python/windpy
$ python loadinfo.py 
{u'_id': u'wind_wset', u'currentIdValue': 0L}

result = counters.find_one({'currentIdValue':0})
print result
---------- 2016-11-15 13:18:20
http://blog.51yip.com/nosql/1639.html

$addToSet 如果数组中没有该数据，向数组中添加数据，如果该数组中有相同数组，不添加
查看复制打印?

    db.test3.insert(  
     {"_id" :6, "grades" : [ "aaa", "bbb", "ccc" ]}  
     );  
      
    db.test3.update( { _id: 6 }, { $addToSet: { grades: "ddd"  } });  

--------- 2016-11-15 11:55:04
keep a counter:
  db.counters.findAndModify({query:{_id:'col01'}, update:{$inc:{'seq':1}}, new:true})
  db.counters.insert({'_id' : 'wind_wset', 'seq' : NumberLong(0)})

before inserting into col01, increment in counters and use the returned row's currentIdValue to insert into col01 with.

-------- 2016-11-15 11:13:36
$ !mongo
mongo -host 10.12.0.36
MongoDB shell version: 2.4.9
connecting to: 10.12.0.36:27017/test
Tue Nov 15 11:09:18.231 Error: couldn't connect to server 10.12.0.36:27017 at src/mongo/shell/mongo.js:147
exception: connect failed

fix: 
  make sure if mongodb is started

$ sudo /etc/init.d/mongodb start
[sudo] password for kidd: 
 * Starting database mongodb                                             [ OK ]

http://localhost:9080/api/v1/wind/sectors?sector=1000000087000000&obj=50

----------- 2016-11-09 21:33:22
http://www.cnblogs.com/stephen-liu74/archive/2012/08/01/2561557.html
  dup key error will fail all latter batch inserts

> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }
> db.col01.ensureIndex({"name":1},{"unique":true})
> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }
> db.col01.insert([{name: 'kidd'}, {name:'jssfy'}])
E11000 duplicate key error index: kidd.col01.$name_1  dup key: { : "kidd" }
> db.col01.insert([{name: 'kidd'}, {name:'jssf'}])
E11000 duplicate key error index: kidd.col01.$name_1  dup key: { : "kidd" }
> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }


------------ 2016-11-09 21:15:03
/usr/lib/python2.7/dist-packages/pymongo/collection.py

there is batch insert but not batch update.

http://blog.csdn.net/xsj_blog/article/details/52032969

---- 2016-11-09 20:43:38
有一千万条文档希望批量得到修改,把一个键的内容拆分成多个键等,比如把字符串转换成时间,怎样能较快完成?
  推荐使用 mongodb 自带的 map-reduce 功能，理论上执行效率会大幅提高，因为 mongodb 会尽可能并行化执行，而不是默认的单线程。

----------- 2016-11-09 19:43:01
http://stackoverflow.com/questions/13959790/pymongo-mongoclient-or-connection

MongoClient is the preferred method of connecting to a mongo instance. The Connection class is deprecated. But, in terms of use they are very similar.

--------- 2016-11-09 17:00:31
> db.wind_wsd.count()
11608
> db.wind_wsd.find({"windcode" : "000905.SH"}).count()
2877
> db.wind_wsd.find({"windcode" : "000903.SH"}).count()
2544
> db.wind_wsd.find({"windcode" : "000001.SH"}).count()
6187


------------ 2016-11-09 15:53:45
windows python support:
  pip install pymongo [this is enough to access remote mongodb]


------- 2016-11-09 15:45:12
> db.stats()
{
  "db" : "apes",
  "collections" : 3,
  "objects" : 15975,
  "avgObjSize" : 205.05001564945226,
  "dataSize" : 3275674,
  "storageSize" : 1536000,
  "numExtents" : 0,
  "indexes" : 3,
  "indexSize" : 192512,
  "ok" : 1
}


------------ 2016-11-09 11:55:54
https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=1.36231715.221700140.1478663373



$ ps -ef | grep mongo
mongodb   1127     1  0 11月08 ?      00:02:51 /usr/bin/mongod --config /etc/mongodb.conf

windows:
下载相应平台的版本，解压即可。为方便使用，将bin路径添加到系统path环境变量里。其中mongod是服务器，mongo是客户shell，然后创建数据文件目录：在c盘下创建data文件夹，里面创建db文件夹。



--------- 2016-11-09 12:07:22
http://www.runoob.com/mongodb/mongodb-create-database.html

/etc/mongodb.conf
bind_ip = 10.12.0.36
#port = 27017

ubuntu

$ mongo
MongoDB shell version: 2.4.9
connecting to: test
> db
test

> show collections
foo
system.indexes
traces
> db.foo.test.insert({a:'1a'})
> show collections
foo
foo.test
system.indexes
traces

$ pip install pymongo

$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> connection=pymongo.Connection('localhost', 27017)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'pymongo' is not defined
>>> import pymongo
>>> connection=pymongo.Connection('localhost', 27017)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/dist-packages/pymongo/connection.py", line 222, in __init__
    max_pool_size, document_class, tz_aware, _connect, **kwargs)
  File "/usr/lib/python2.7/dist-packages/pymongo/mongo_client.py", line 352, in __init__
    raise ConnectionFailure(str(e))
pymongo.errors.ConnectionFailure: could not connect to localhost:27017: [Errno 111] Connection refused
>>> connection=pymongo.Connection('10.12.0.36', 27017)

other cmds:
  db=connection.test
  collection=db.coll
  post = {"author": "Mike"}
  posts = db.posts
>>> posts.insert(post)
ObjectId('5822a3c18f617257106e37fb')
>>> db.collection_names()
[u'system.indexes', u'traces', u'foo', u'foo.test', u'posts']

import pymongo
connection=pymongo.Connection('10.12.0.36', 27017) # for windows: pymongo.MongoClient('10.12.0.36', 27017)
db=connection.kidd
collection=db.wind_wsd
doc = {"author": "Mike"}
collection.insert(doc)

------- 2016-11-09 13:16:39
1.文档
  文档时mongodb中数据的基本单元，类似关系型数据库中的行。
  >>关系型数据库：
    行：是标识一条存在数据库中的记录，行有唯一标识的字段，比如oracle就有隐藏存在的rowid。行有列，标识对应字段的名称，字段值为列所表示的值。
  >>Mongodb
    文档：标识集合中的一条记录，即集合中的一个对象，形象的对比：数组中的一个元素，List中的一个元素等（个人理解）。文档有唯一的标识“_id”,数据库可自动生成，可类比oracle的rowid。
          文档以key/value的方式,如下文档：
          {"name":"jack","age":20}
          可类比数据表的列，以及列对应的值。

2.集合
  集合在mongodb中是一组文档，类似关系型数据库中的数据表。
  >>关系型数据库：
    表:是存储多个数据的，表中存在多行。表，即模式.表名。表中的数据行在列数、列的类型都是一样。
    select * from [模式].表名
  >>Mongodb
    mongodb数据库不是关系型数据库，没有模式的概念。集合中的文档可以使不同形式的。比如：
    {"name":"jack","age":19}
    {"name":"wangjun","age":22,"sex":"1"}
   
    可以存在同一个集合当中。
   
    集合是由唯一的命名来标识，满足以下条件的任意UTF-8字符串：
    >集合名不能使空字符串""
    >集合名不能含有\0字符（空字符），这个字符标识集合名的结尾
    >集合名不能以"system."开头，该为系统集合保留的前缀
    >用户创建的集合名字不能含有保留字符$
   
    比如：集合classes   classes的子集合students  查询方式：
    db.classes.find()
    db.classes.students.find()


3.数据库
  mongodb中多个文档构成集合，多个集合构成数据库。
  >>关系型数据库
    在安装数据库的时候数据库实例创建，同时存在系统默认的管理员用户。之后可以创建多个用户并进行赋权，创建的表存在于不同的用户之下，不同的用户存储着不同的数据。
  >>Mongodb
    mongodb以文档的形式保存在集合中，可以同一数据库存储不同的数据或者集合，即DB2、oracle、teradata等都可以存储在同一个数据库中。最近做的项目就可以将这三者数据库的数据都保存到同一数据库中。
   
    mongodb服务器可以存在多应用或者用户的数据，可以相互独立。数据库的命名规则：
    >不能使空字符串（""）
    >不得含有''（空格）、.、$、/、|和\0（空字符）
    >应全部小写
    >最多64字节
   
    保留数据库名：admin、local、config

shell操作：
1.创建：db.a.insert({"name":"jack","age":19})
        db.a.insert({"name":"luce","age":20})
       
2.查找：db.a.find()                  --全查
        db.a.findOne()               --只取多个的第一个
        db.a.find({"name":"jack"})   --根据条件查找
       
3.更新：db.a.update({"name":"jack"},{"age":30})

4.删除：db.a.remove()                --删除所有文档，集合保留
        db.a.remove({"name":"jack"}) --删除复合条件的文档
        db.a.drop()                  --删除集合，于此同时所有文档也删除了
        db.dropDatabase()            -- drop the current database


----------- 2016-11-09 13:35:11
$ du -sh /var/lib/mongodb/*
3.1G  /var/lib/mongodb/journal
64M /var/lib/mongodb/kidd.0
129M  /var/lib/mongodb/kidd.1
17M /var/lib/mongodb/kidd.ns
64M /var/lib/mongodb/local.0
17M /var/lib/mongodb/local.ns
64M /var/lib/mongodb/microblog.0
129M  /var/lib/mongodb/microblog.1
17M /var/lib/mongodb/microblog.ns
4.0K  /var/lib/mongodb/mongod.lock
65M /var/lib/mongodb/test.0
129M  /var/lib/mongodb/test.1
17M /var/lib/mongodb/test.ns
4.0K  /var/lib/mongodb/_tmp

-------- 2016-11-09 20:22:33
> db.col01.update({ "_id" : ObjectId("5822b0b29e54c21d76fe1049")}, { "_id" : ObjectId("5822b0b29e54c21d76fe1049"), name : "菜鸟教程2", age:12 })
> db.col01.find()
{ "_id" : ObjectId("5822b0b59e54c21d76fe104a"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b69e54c21d76fe104b"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b69e54c21d76fe104c"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b79e54c21d76fe104d"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b29e54c21d76fe1049"), "name" : "菜鸟教程2", "age" : 12 }

  when updating, the key can be without quotes. and the number value can be without quotes, but string not.
-------------- 2016-11-15 18:30:10

java


    @POST
    @Path("result")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public static JsonObject result(
            JsonObject body
    ) {
        long start = System.currentTimeMillis();

        JsonObjectBuilder builder = Json.createObjectBuilder();

        // cmd : string
        // param : array
        // data : object
        //      codeList : codes
        //      fieldList : fields
        //      timeList : times
        //      data : arrays
        //      errorCode : error status

        String cmd = body.getString("cmd");
        JsonString dataStr = body.getJsonString("data");
        // sample data
        // {"codeList":["000903.SH"],"fieldList":["OPEN","HIGH","SEC_NAME"],"timeList":["2016-11-08T00:00:00","2016-11-09T00:00:00","2016-11-10T00:00:00"],"data":[3156.0273,3172.436,"中证100",3157.6802,3162.2534,"中证100",3162.8038,3193.9868,"中证100"],"errorCode":0}
        JsonObject data = StringUtils.parseJson(dataStr.getString());
        JsonArray codeList = data.getJsonArray("codeList"); // codeList does not work if there are multiple windcodes for wsi
        JsonArray fieldList = data.getJsonArray("fieldList"); // there is a "windcode" field if there are multiple windcodes for wsi
        JsonArray timeList = data.getJsonArray("timeList");
        JsonArray dataArray = data.getJsonArray("data");
        int error = data.getInt("errorCode");
        if (error != 0) {
            logger.error("error occurred, to exit with " + error);
            return builder.build();
        }

        logger.info("cmd is: " + cmd);
        logger.info("code list size is: " + codeList.size());
        logger.info("field list size is: " + fieldList.size());
        logger.info("time list size is: " + timeList.size());
        String temp = dataArray.toString();
        // there might be different value type in dataArray
        // JsonArray does not provide any api to judge which method to call to access member
        // getJsonObject or getJsonNumber or others
        // hence parse the data string into an object array
        Object[] dataArr = temp.substring(1, temp.length()-1).split(",");
//        logger.info("recved data: " + temp);

        // before upserting, all wincode keeps upper case, and all other keys are converted to lower case
        int fieldsSize = fieldList.size();
        if (cmd.equals("wsd")) {
            String windcode = codeList.getString(0);
            for (int i = 0; i < timeList.size(); ++i) {
                Document doc = new Document();
                doc.append("windcode", windcode);
                doc.append("create_at", System.currentTimeMillis());
                Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                doc.append("date", dateLong);
                for (int j = 0; j < fieldsSize; ++j) {
                    doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                }
                MongoUtil.upsertWindWsdEntry(windcode, dateLong, doc);
            }
        } else if (cmd.equals("wsi")) {
            boolean multiple = false;
            for (int i = 0; i < fieldList.size(); ++i) {
                if (fieldList.getString(i).equals("windcode")) {
                    // there are multiple windcodes
                    multiple = true;
                    break;
                }
            }
            if (multiple) {
                for (int i = 0; i < timeList.size(); ++i) {
                    Document doc = new Document();
                    doc.append("create_at", System.currentTimeMillis());
                    Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                    doc.append("date", dateLong);
                    String windcode = "";
                    for (int j = 0; j < fieldList.size(); ++j) {
                        doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                        if (fieldList.getString(j).toLowerCase().equals("windcode")) {
                            windcode = dataArr[i * fieldsSize + j].toString();
                        }
                    }
                    MongoUtil.upsertWindWsiEntry(windcode, dateLong, doc);
                }
            } else {
                // windcode in codeList, same as wsd, but call upsertWindWsiEntry instead
                String windcode = codeList.getString(0);
                for (int i = 0; i < timeList.size(); ++i) {
                    Document doc = new Document();
                    doc.append("windcode", windcode);
                    doc.append("create_at", System.currentTimeMillis());
                    Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                    doc.append("date", dateLong);
                    for (int j = 0; j < fieldList.size(); ++j) {
                        doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                    }
                    MongoUtil.upsertWindWsiEntry(windcode, dateLong, doc);
                }
            }
        } else if (cmd.equals("wset")) {
            Long objId;
            if (null != body.getJsonNumber("objId")) {
                objId = body.getJsonNumber("objId").longValue();

                List<Document> docs = new ArrayList<>();
                int rows = dataArr.length / fieldsSize;
                for (int i = 0; i < rows; ++i) {
                    if (MongoUtil.hasWindWsetEntry(dataArr[i * fieldsSize + 1].toString())) {
//                        logger.info(dataArr[i * fieldsSize + 1].toString() + ": having windwset entry already");
                        Document doc = new Document();
                        doc.append("sectors", objId);
                        MongoUtil.updateWindWsetEntry(dataArr[i * fieldsSize + 1].toString(), doc);
                    } else {
//                        logger.info(dataArr[i * fieldsSize + 1].toString() + ": not having windwset entry yet");
                        Document doc = new Document();
                        doc.append("_id", MongoUtil.getNextSequence("wind_wset"));
                        List<Long> objIdArray = new ArrayList<>();
                        objIdArray.add(objId);
                        doc.append("sectors", objIdArray);
                        Long dateLong = TimeUtil.date2TimeStamp(dataArr[i * fieldsSize].toString().replaceFirst("T", " ").replace("\"", ""), "yyyy-MM-dd HH:mm:ss");
                        doc.append("date", dateLong);
                        doc.append("create_at", System.currentTimeMillis());
                        doc.append("windcode", dataArr[i * fieldsSize + 1].toString());
                        doc.append("sec_name", dataArr[i * fieldsSize + 2].toString());
                        docs.add(doc);
                    }
                }
                if (docs.size() > 0) {
                    MongoUtil.insertWindWsetEntries(docs);
                }
            } else {
                logger.error("obj id not existing for returned wset results");
            }
        }

        long end = System.currentTimeMillis();

        logger.info("spent " + (end-start) + "ms in total");

        return builder.build();
    }


    public static boolean updateWindWsetEntry(String windCode, Document doc) {
        MongoCollection<Document> col = database.getCollection(MongoUtil.WIND_WSET_COL);
        col.updateOne(eq("windcode", windCode), new Document("$addToSet", doc));
        return true;
    }

    public static boolean insertWindWsetEntries(List<Document> docs) {
        MongoCollection<Document> col = database.getCollection(MongoUtil.WIND_WSET_COL);
        col.insertMany(docs);
        return true;
    }




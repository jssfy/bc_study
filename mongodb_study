
shell cmds:
  show dbs
  use db_name
  db.stats()

---------- 2017-02-04 12:00:49
ISODate

> db.kidd.insert({mydate:ISODate("2012-11-02T07:58:51.718Z")})
> db.kidd.find()
{ "_id" : ObjectId("589551d97e5942429ca79d0c"), "mydate" : ISODate("2012-11-02T07:58:51.718Z") }

日期字符串也支持多种格式
neu:PRIMARY> db.t2.insert({mydate:ISODate("2012-11-02 07:58:51")})
neu:PRIMARY> db.t2.insert({mydate:ISODate("20121102 07:58:51")})
neu:PRIMARY> db.t2.insert({mydate:ISODate("20121102")}) 

我们比较一下mongo中的当前时间与系统当前时间：
> new Date()
ISODate("2017-02-04T04:05:02.471Z")
$ date
2017年 02月 04日 星期六 12:05:31 CST
这是因为mongo中的date类型以UTC（Coordinated Universal Time）存储，就等于GMT（格林尼治标准时）时间。而系统时间使用的是GMT+0800时间，两者正好相差8个小时。
在python中，与之对应的日期是 datetime.datetime.utcnow()，而不是now()，两者正好差8个小时：
>>> import datetime 
 >>> datetime.datetime.utcnow()
datetime.datetime(2012, 11, 2, 8, 22, 52, 953000)
>>> datetime.datetime.now()
datetime.datetime(2012, 11, 2, 16, 22, 58, 218000) 


def isodate_test():
  # info_connection=pymongo.MongoClient('10.12.6.43', 27017)
  info_connection=pymongo.MongoClient('10.12.0.11', 27017)
  info_db=info_connection.test
  info_col=info_db.kidd
  ts = time.time()
  t = datetime.datetime.fromtimestamp(ts)
  doc = {'date' : t, 'windcode' : '000001.SZ'}
  info_col.update({'windcode': doc['windcode'], 'date' : doc['date']}, {'$set': doc}, upsert=True)

{ "_id" : ObjectId("589554e6485833dfc31cacc4"), "date" : ISODate("2017-02-04T12:13:26.255Z"), "windcode" : "000001.SZ" }

in edbspider:
  row['dateObj'] = datetime.fromtimestamp(row['date'] / 1000)
> db.wind_edb.find({date : 1485100800000})
{ "_id" : ObjectId("58870383878544f6a1e5311e"), "date" : NumberLong("1485100800000"), "M0061577" : 3.95, "S2703478" : 68.39, "S2703479" : 33.69, "M0061614" : "NaN", "S2707388" : "NaN", "S2707387" : "NaN", "S2703476" : 65.29, "S2703477" : 47.37, "S2703480" : 50.19, "S2703481" : 71.65, "M0062611" : 1867.03, "dateObj" : ISODate("2017-01-23T00:00:00Z") }



--------- 2017-02-03 18:06:48
db.wind_edb.find().sort({date : -1}).limit(1).pretty()

如果有多个字段,按姓名降序，年龄升序
db.user.find().sort({"name":-1,"age":1})
limit和skip一起用，相当于mysql里的limit:
b.user.find().skip(1).limit(1)
相当于mysql里的limit(1,1)，即跳过第0条，从第1条开始返回，只返回1条

--------- 2017-02-03 15:43:27
使用第二个参数，指定显示的列
  db.measures.find({'datasetId': 'wind_edb'}, {id : 1});

------------- 2017-01-14 12:10:07


db.wind_wsd.find({date : {$gte : 1480262400000, $lte : 1484150400000}, "windcode":{"$in":['000001.SH',"000903.SH","000904.SH","000905.SH","000906.SH","000300.SH","399001.SZ","399005.SZ","399006.SZ"]}}).count()
414

$ mongoexport -h 10.12.6.6 -d apes -c wind_wsd -f "close,date,windcode" -q '{date : {$gte : 1480262400000, $lte : 1484150400000}, "windcode":{"$in":["000001.SH","000903.SH","000904.SH","000905.SH","000906.SH","000300.SH","399001.SZ","399005.SZ","399006.SZ"]}}' -o ~/tmp/wind_wsd_02.dat
connected to: 10.12.6.6
exported 414 records


$ mongoexport -h 10.12.6.6 -d apes -c wind_wsd -f "close,date,windcode" -q "{date : 1451577600000}" -o ~/tmp/wind_wsd.dat
connected to: 10.12.6.6
exported 9 records


--------- 2017-01-14 11:37:23
$ mongoimport -h 10.12.6.43 -d apes -c wind_wsd ~/tmp/wind_wsd.dat 
connected to: 10.12.6.43
Sat Jan 14 11:34:12.543 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b67d878544f6a1e4739c') }
Sat Jan 14 11:34:12.543 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b696878544f6a1e4739d') }
Sat Jan 14 11:34:12.543 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b696878544f6a1e4739e') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b696878544f6a1e4739f') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b697878544f6a1e473a0') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b697878544f6a1e473a1') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b698878544f6a1e473a2') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b698878544f6a1e473a3') }
Sat Jan 14 11:34:12.544 E11000 duplicate key error index: apes.wind_wsd.$_id_  dup key: { : ObjectId('5878b698878544f6a1e473a4') }
Sat Jan 14 11:34:12.545 imported 9 objects

$ mongoimport -h 10.12.6.43 -d apes -c wind_wsd --upsert ~/tmp/wind_wsd.dat 
connected to: 10.12.6.43
Sat Jan 14 11:34:41.520 imported 9 objects


----------- 2017-01-13 17:44:47
> db.kidd.find({"abc.aggs.0.start":0})
{ "_id" : ObjectId("58789f9b70355120fa0f03b0"), "abc" : { "aggs" : [  {  "start" : 0,  "end" : 1 } ] } }



-------------- 2017-01-13 17:25:37
> db.kidd.insert({'abc' : {'name' : 'kidd', 'age' : 2}})
> db.kidd.find().pretty()
{ "_id" : ObjectId("586e1a069a6a2a8a39d41fbe"), "name" : "kidd" }
{
  "_id" : ObjectId("58789ce770355120fa0f03af"),
  "abc" : {
    "name" : "kidd",
    "age" : 2
  }
}
> db.kidd.find({'abc.name' : 'kidd' }).pretty()
{
  "_id" : ObjectId("58789ce770355120fa0f03af"),
  "abc" : {
    "name" : "kidd",
    "age" : 2
  }
}

http://blog.csdn.net/shellching/article/details/7651721
db.kidd.update({}, {$rename : {"abc.name" : "abc.modified_name"}}, false, true)
db.kidd.update({}, {$rename : {"abc.modified_name" : "abc.:name"}}, false, true)

------------ 2017-01-13 16:13:49
默认情况下，find方法会返回所有的键，类似于SQL中的select *,如果要指定返回的字段，需要用到find的第二个参数：

上面的命令是查询user集合(表),在返回的结果中，不返回_id键，第二个参数是需要过滤的键，而不是要显示的键。
如果同时要过滤age键:

db.user.find({},{"_id":0,"age":0})


----------- 2017-01-13 15:36:09
Fri Jan 13 15:34:18.168 ERROR: Error creating index apes.charts: 16633 err: "text search not enabled"
Aborted (core dumped)

FIX:
  add
    setParameter=textSearchEnabled=true

  to /etc/mongodb.conf

  sudo mongod --config /etc/mongodb.conf

failed with another error: 
  Fri Jan 13 15:38:50.806   Creating index: { key: { _id: 1 }, name: "_id_", ns: "apes.charts" }
  Fri Jan 13 15:38:50.853   Creating index: { key: { _fts: "text", _ftsx: 1 }, name: "title_text", default_language: "english", language_override: "language", ns: "apes.charts", weights: { title: 1 }, textIndexVersion: 3 }
  Fri Jan 13 15:38:50.905 ERROR: Error creating index apes.charts: 16633 err: "text search not enabled"
  Aborted (core dumped)



------ 2017-01-11 11:42:27
for upsert in python, the comparison fields will be inserted automatically even the doc does not include it.

def upsert_information(windcode, doc):
  info_connection=pymongo.MongoClient('10.12.6.6', 27017)
  info_db=info_connection.test
  info_col=info_db.kidd
  info_col.update({'windcode': windcode, 'age' : 30}, {'$set': doc}, upsert=True)


if __name__ == "__main__":
  # print get_information_measurements()
  doc = {
    'name' : 'kidd',
          }
  upsert_information('000001.SZ', doc)

> db.wind_wsd.update({_id : ObjectId("5878b698878544f6a1e473a4")}, {$set : {'close' : 111.111}})
> db.wind_wsd.find({'_id' : ObjectId("5878b698878544f6a1e473a4")}).pretty()
{
  "_id" : ObjectId("5878b698878544f6a1e473a4"),
  "date" : NumberLong("1451577600000"),
  "windcode" : "399006.SZ",
  "close" : 111.111
}

------- 2017-01-10 11:23:44
db.wind_performance.find({ "west_sales_downgrade" : {$exists : true}}).pretty()

------------ 2017-01-09 16:08:58
db.course.find( { "lectures.lectures_count": { $exists: true } } )
查询course表中，存在lectures_count字段的记录信息
删除course表中，所有的lectures.lectures_count字段
db.course.update({},{$unset:{"lectures.lectures_count":""}},{multi:true})
根据条件往表里插入一个字段
db.lecture.update({"course_id":"5352d5ab92fc7705666ae8c9"},{$set:{"file_type":"PDF"}},{multi:true})

--------- 2016-12-30 15:14:00
模糊查询：tname包含某个关键字测试'
cd /opt/soft/mongodb/bin
./mongo --host 192.168.0.1  --port 17017  test
db.test_info.find({"tname": {$regex: '测试', $options:'i'}}) 
db.test_info.find({"tname": {$regex:/测试.*/i}})  

----------- 2016-11-29 20:31:04
BSON是由10gen开发的一个数据格式，目前主要用于MongoDB中，是MongoDB的数据存储格式。BSON基于JSON格式，选择JSON进行改造的原因主要是JSON的通用性及JSON的schemaless的特性。
BSON主要会实现以下三点目标：
1.更快的遍历速度
对JSON格式来说，太大的JSON结构会导致数据遍历非常慢。在JSON中，要跳过一个文档进行数据读取，需要对此文档进行扫描才行，需要进行麻烦的数据结构匹配，比如括号的匹配，而BSON对JSON的一大改进就是，它会将JSON的每一个元素的长度存在元素的头部，这样你只需要读取到元素长度就能直接seek到指定的点上进行读取了。
2.操作更简易
对JSON来说，数据存储是无类型的，比如你要修改基本一个值，从9到10，由于从一个字符变成了两个，所以可能其后面的所有内容都需要往后移一位才可以。而使用BSON，你可以指定这个列为数字列，那么无论数字从9长到10还是100，我们都只是在存储数字的那一位上进行修改，不会导致数据总长变大。当然，在MongoDB中，如果数字从整形增大到长整型，还是会导致数据总长变大的。
3.增加了额外的数据类型
JSON是一个很方便的数据交换格式，但是其类型比较有限。BSON在其基础上增加了“byte array”数据类型。这使得二进制的存储不再需要先base64转换后再存成JSON。大大减少了计算开销和数据大小。
当然，在有的时候，BSON相对JSON来说也并没有空间上的优势，比如对{“field”:7}，在JSON的存储上7只使用了一个字节，而如果用BSON，那就是至少4个字节（32位）
目前在10gen的努力下，BSON已经有了针对多种语言的编码解码包。并且都是Apache 2 license下开源的。并且还在随着MongoDB进一步地发展。

MongoDB使用BSON做为文档数据存储和网络传输格式

http://suo.iteye.com/blog/1073243
按照官方的说法，MongoDB是一种可扩展的高性能的开源的面向文档（document-oriented ）的数据库，采用C++开发。
    面向文档，那么什么是文档呢？很明显这不是我们常见的word文档。这里说的文档，是一种可以嵌套的数据集合。从关系数据库的范式的概念来说，嵌套是明显的反范式设计。范式设计的好处是消除了依赖，但是增加了关联，查询需要通过关联两张或者多张表来获得所需要的全部数据，但是更改操作是原子的，只需要修改一个地方即可。反范式则是增加了数据冗余来提升查询性能，但更新操作可能需要更新冗余的多处数据，需要注意一致性的问题。


---------- 2016-11-28 14:34:03


mongodb现有的数据是这样
    {  
      "_id" : ObjectId("4ec0b2a4ecb31ca1968000fd"),  
      "id" : 1001,  
      "singer" : "刘德华",  
      "someReview" : [{  
          "user" : "dong",  
          "text" : "不好听"  
        }, {  
          "user" : "wan",  
          "text" : "打酱油"  
        }, {  
          "user" : "wan",  
          "text" : "真的挺不错，一直很喜欢刘德华"  
        }]  
    }  
 查出的结果是
    {  
          "user" : "wan",  
          "text" : "打酱油"  
    }      
 请问改怎么查？？谢谢

楼主，你好，假如你的表(collection)叫test，可以这样做，
db.test.find({"someReview.user":"wan"},{"someReview.user":1,"someReview.text":1})
第一个参数是查询条件，第二参数是要查询的字段

db.things.find( { someReview.user: "wan" } );

> use test
switched to db test
> db.test.insert([{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}])
> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
> db.test.insert({[{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}]})
Mon Nov 28 14:41:07.671 SyntaxError: Unexpected token [
> db.test.insert({array : [{'name' : 'kidd', 'age' : 5}, {'name' : 'jssfy', age : 6}]})
> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }
> db.test.find({array.name : kidd})
Mon Nov 28 14:41:49.518 SyntaxError: Unexpected token .
> db.test.find({array.name : 'kidd'})
Mon Nov 28 14:41:54.374 SyntaxError: Unexpected token .
> db.test.find({'array.name' : 'kidd'})
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }

> db.test.find()
{ "_id" : ObjectId("583bd14667e7f31d19e6f506"), "name" : "kidd", "age" : 5 }
{ "_id" : ObjectId("583bd14667e7f31d19e6f507"), "name" : "jssfy", "age" : 6 }
{ "_id" : ObjectId("583bd19367e7f31d19e6f508"), "array" : [  {  "name" : "kidd",  "age" : 5 },  {  "name" : "jssfy",  "age" : 6 } ] }
{ "_id" : ObjectId("583bd37867e7f31d19e6f509"), "fruits" : [  "apple",  "banana",  "pear" ] }
> db.test.find({fruits : 'banana'})
{ "_id" : ObjectId("583bd37867e7f31d19e6f509"), "fruits" : [  "apple",  "banana",  "pear" ] }

----------- 2016-11-21 14:47:10
db.tushare_information.update({}, {$unset:{'area' : ''}}, {multi: true})
删除表中，所有的字段

---------- 2016-11-21 12:28:51
$ python tushare_information.py 
/usr/lib/python2.7/dist-packages/pkg_resources.py:1031: UserWarning: /home/kidd/.python-eggs is writable by group/others and vulnerable to attack when used with get_resource_filename. Consider a more secure location (set with .set_extraction_path or the PYTHON_EGG_CACHE environment variable).
  warnings.warn(msg, UserWarning)
[Getting data:]#################################################got 2847 rows
<type 'dict'>
{u'updatedExisting': True, u'connectionId': 11, u'ok': 1.0, u'err': None, u'n': 1}


------------ 2016-11-17 18:50:20
use pretty() to format:
  db.performance.find().pretty()

------------- 2016-11-17 14:48:40
mongodb cursor id not valid error是一个超时错误。
当使用for  c  in  col.find()时，数据库会一次性返回很多数据，如果处理这些数据的时间超过10分钟，一直没有像数据库获取后续数据，则会出现上述错误。
 
解决方案：
取消timeout限制，在结束遍历后close()游标。
cursor = coll.find(timeout=False)
for c in cursor:
    ...
    ...
cursor.close()
 
 
其他方案：
上面那个方案是我使用后成功的。还有几种方案，我尝试了一下，无效，不知道为什么。
解决方案2：
用batch_size()限制一次获取的数据量
for c in col.find().batch_size(20):
    ...
 
解决方案3：
用no_cursor_timeout参数去掉时间限制。注意后面要close()游标。
cursor=db.images.find(no_cursor_timeout=True)
for i in cursor:
   .....
   .....
cursor.close()

-------- 2016-11-17 12:55:01
export and import
http://chenzhou123520.iteye.com/blog/1641319

$ mongoexport -h 10.12.6.6 -d apes -c measurements -o ~/tmp/measurements.dat
connected to: 10.12.6.6
exported 202 records

-q:指明导出数据的过滤条件
$ mongoexport -h 10.12.6.6 -d apes -c wind_wsd -q "{date : 1451577600000}" -o ~/tmp/wind_wsd.dat
connected to: 10.12.6.6
exported 9 records



$ mongoimport -h 10.12.0.36 -d apes -c measurements ~/tmp/measurements.dat 
connected to: 10.12.0.36
Thu Nov 17 12:56:08.134 check 9 202
Thu Nov 17 12:56:08.137 imported 202 objects

-d    指定把数据导入到哪一个数据库中
-c    指定把数据导入到哪一个集合中
--type    指定导入的数据类型
--file       指定从哪一个文件中导入数据
--headerline    仅适用于导入csv,tsv格式的数据，表示文件中的第一行作为数据头
--upsert  以新增或者更新的方式来导入数据

mongodb数据备份和还原主要分为二种，一种是针对于库的mongodump和mongorestore，一种是针对库中表的mongoexport和mongoimport。 
mongodump -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 -o 文件存在路径 
mongodump -h 10.12.6.43 -d hb -o /tmp/hb.dump
mongodump -h 10.51.3.146 --port 3017 -d apes -o apes.dump

$ tree /tmp/hb.dump/
/tmp/hb.dump/
└── hb
    ├── hb_charts.bson
    ├── hb_charts.metadata.json
    └── system.indexes.bson

mongorestore -h IP --port 端口 -u 用户名 -p 密码 -d 数据库 --drop 文件存在路径
mongorestore -h 10.12.6.43 --drop apes.dump

-------------- 2016-11-16 11:03:44
search

db.measurements.find({"path" : /预测评级/ })




------------ 2016-11-15 13:34:15
$ python loadinfo.py 
None
kidd@kidd-OptiPlex-9020:
~/workspace/python/windpy
$ python loadinfo.py 
{u'_id': u'wind_wset', u'currentIdValue': 0L}

result = counters.find_one({'currentIdValue':0})
print result
---------- 2016-11-15 13:18:20
http://blog.51yip.com/nosql/1639.html

$addToSet 如果数组中没有该数据，向数组中添加数据，如果该数组中有相同数组，不添加
查看复制打印?

    db.test3.insert(  
     {"_id" :6, "grades" : [ "aaa", "bbb", "ccc" ]}  
     );  
      
    db.test3.update( { _id: 6 }, { $addToSet: { grades: "ddd"  } });  

---------- 2017-01-09 13:25:29
print pymongo.__version__
3.4.0

--------- 2016-11-15 11:55:04
keep a counter:
  db.counters.findAndModify({query:{_id:'col01'}, update:{$inc:{'seq':1}}, new:true})
  db.counters.insert({'_id' : 'wind_wset', 'seq' : NumberLong(0)})

before inserting into col01, increment in counters and use the returned row's currentIdValue to insert into col01 with.

-------- 2016-11-15 11:13:36
$ !mongo
mongo -host 10.12.0.36
MongoDB shell version: 2.4.9
connecting to: 10.12.0.36:27017/test
Tue Nov 15 11:09:18.231 Error: couldn't connect to server 10.12.0.36:27017 at src/mongo/shell/mongo.js:147
exception: connect failed

fix: 
  make sure if mongodb is started

$ sudo /etc/init.d/mongodb start
[sudo] password for kidd: 
 * Starting database mongodb                                             [ OK ]

http://localhost:9080/api/v1/wind/sectors?sector=1000000087000000&obj=50

----------- 2016-11-09 21:33:22
http://www.cnblogs.com/stephen-liu74/archive/2012/08/01/2561557.html
  dup key error will fail all latter batch inserts

> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }
> db.col01.ensureIndex({"name":1},{"unique":true})
> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }
> db.col01.insert([{name: 'kidd'}, {name:'jssfy'}])
E11000 duplicate key error index: kidd.col01.$name_1  dup key: { : "kidd" }
> db.col01.insert([{name: 'kidd'}, {name:'jssf'}])
E11000 duplicate key error index: kidd.col01.$name_1  dup key: { : "kidd" }
> db.col01.find()
{ "_id" : ObjectId("582324df424edad4cd86ebf4"), "name" : "kidd" }
{ "_id" : ObjectId("582324df424edad4cd86ebf5"), "name" : "jssfy" }


------------ 2016-11-09 21:15:03
/usr/lib/python2.7/dist-packages/pymongo/collection.py

there is batch insert but not batch update.

http://blog.csdn.net/xsj_blog/article/details/52032969

---- 2016-11-09 20:43:38
有一千万条文档希望批量得到修改,把一个键的内容拆分成多个键等,比如把字符串转换成时间,怎样能较快完成?
  推荐使用 mongodb 自带的 map-reduce 功能，理论上执行效率会大幅提高，因为 mongodb 会尽可能并行化执行，而不是默认的单线程。

----------- 2016-11-09 19:43:01
http://stackoverflow.com/questions/13959790/pymongo-mongoclient-or-connection

MongoClient is the preferred method of connecting to a mongo instance. The Connection class is deprecated. But, in terms of use they are very similar.

--------- 2016-11-09 17:00:31
> db.wind_wsd.count()
11608
> db.wind_wsd.find({"windcode" : "000905.SH"}).count()
2877
> db.wind_wsd.find({"windcode" : "000903.SH"}).count()
2544
> db.wind_wsd.find({"windcode" : "000001.SH"}).count()
6187


------------ 2016-11-09 15:53:45
windows python support:
  pip install pymongo [this is enough to access remote mongodb]


------- 2016-11-09 15:45:12
> db.stats()
{
  "db" : "apes",
  "collections" : 3,
  "objects" : 15975,
  "avgObjSize" : 205.05001564945226,
  "dataSize" : 3275674,
  "storageSize" : 1536000,
  "numExtents" : 0,
  "indexes" : 3,
  "indexSize" : 192512,
  "ok" : 1
}


------------ 2016-11-09 11:55:54
https://www.mongodb.org/dl/win32/x86_64-2008plus-ssl?_ga=1.36231715.221700140.1478663373



$ ps -ef | grep mongo
mongodb   1127     1  0 11月08 ?      00:02:51 /usr/bin/mongod --config /etc/mongodb.conf

windows:
下载相应平台的版本，解压即可。为方便使用，将bin路径添加到系统path环境变量里。其中mongod是服务器，mongo是客户shell，然后创建数据文件目录：在c盘下创建data文件夹，里面创建db文件夹。



--------- 2016-11-09 12:07:22
http://www.runoob.com/mongodb/mongodb-create-database.html

/etc/mongodb.conf
bind_ip = 10.12.0.36
#port = 27017

ubuntu

$ mongo
MongoDB shell version: 2.4.9
connecting to: test
> db
test

> show collections
foo
system.indexes
traces
> db.foo.test.insert({a:'1a'})
> show collections
foo
foo.test
system.indexes
traces

$ pip install pymongo

$ python
Python 2.7.6 (default, Jun 22 2015, 17:58:13) 
[GCC 4.8.2] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> connection=pymongo.Connection('localhost', 27017)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'pymongo' is not defined
>>> import pymongo
>>> connection=pymongo.Connection('localhost', 27017)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "/usr/lib/python2.7/dist-packages/pymongo/connection.py", line 222, in __init__
    max_pool_size, document_class, tz_aware, _connect, **kwargs)
  File "/usr/lib/python2.7/dist-packages/pymongo/mongo_client.py", line 352, in __init__
    raise ConnectionFailure(str(e))
pymongo.errors.ConnectionFailure: could not connect to localhost:27017: [Errno 111] Connection refused
>>> connection=pymongo.Connection('10.12.0.36', 27017)

other cmds:
  db=connection.test
  collection=db.coll
  post = {"author": "Mike"}
  posts = db.posts
>>> posts.insert(post)
ObjectId('5822a3c18f617257106e37fb')
>>> db.collection_names()
[u'system.indexes', u'traces', u'foo', u'foo.test', u'posts']

import pymongo
connection=pymongo.Connection('10.12.0.36', 27017) # for windows: pymongo.MongoClient('10.12.0.36', 27017)
db=connection.kidd
collection=db.wind_wsd
doc = {"author": "Mike"}
collection.insert(doc)

------- 2016-11-09 13:16:39
1.文档
  文档时mongodb中数据的基本单元，类似关系型数据库中的行。
  >>关系型数据库：
    行：是标识一条存在数据库中的记录，行有唯一标识的字段，比如oracle就有隐藏存在的rowid。行有列，标识对应字段的名称，字段值为列所表示的值。
  >>Mongodb
    文档：标识集合中的一条记录，即集合中的一个对象，形象的对比：数组中的一个元素，List中的一个元素等（个人理解）。文档有唯一的标识“_id”,数据库可自动生成，可类比oracle的rowid。
          文档以key/value的方式,如下文档：
          {"name":"jack","age":20}
          可类比数据表的列，以及列对应的值。

2.集合
  集合在mongodb中是一组文档，类似关系型数据库中的数据表。
  >>关系型数据库：
    表:是存储多个数据的，表中存在多行。表，即模式.表名。表中的数据行在列数、列的类型都是一样。
    select * from [模式].表名
  >>Mongodb
    mongodb数据库不是关系型数据库，没有模式的概念。集合中的文档可以使不同形式的。比如：
    {"name":"jack","age":19}
    {"name":"wangjun","age":22,"sex":"1"}
   
    可以存在同一个集合当中。
   
    集合是由唯一的命名来标识，满足以下条件的任意UTF-8字符串：
    >集合名不能使空字符串""
    >集合名不能含有\0字符（空字符），这个字符标识集合名的结尾
    >集合名不能以"system."开头，该为系统集合保留的前缀
    >用户创建的集合名字不能含有保留字符$
   
    比如：集合classes   classes的子集合students  查询方式：
    db.classes.find()
    db.classes.students.find()


3.数据库
  mongodb中多个文档构成集合，多个集合构成数据库。
  >>关系型数据库
    在安装数据库的时候数据库实例创建，同时存在系统默认的管理员用户。之后可以创建多个用户并进行赋权，创建的表存在于不同的用户之下，不同的用户存储着不同的数据。
  >>Mongodb
    mongodb以文档的形式保存在集合中，可以同一数据库存储不同的数据或者集合，即DB2、oracle、teradata等都可以存储在同一个数据库中。最近做的项目就可以将这三者数据库的数据都保存到同一数据库中。
   
    mongodb服务器可以存在多应用或者用户的数据，可以相互独立。数据库的命名规则：
    >不能使空字符串（""）
    >不得含有''（空格）、.、$、/、|和\0（空字符）
    >应全部小写
    >最多64字节
   
    保留数据库名：admin、local、config

shell操作：
1.创建：db.a.insert({"name":"jack","age":19})
        db.a.insert({"name":"luce","age":20})
       
2.查找：db.a.find()                  --全查
        db.a.findOne()               --只取多个的第一个
        db.a.find({"name":"jack"})   --根据条件查找
       
3.更新：db.a.update({"name":"jack"},{"age":30})

4.删除：db.a.remove()                --删除所有文档，集合保留
        db.a.remove({"name":"jack"}) --删除复合条件的文档
        db.a.drop()                  --删除集合，于此同时所有文档也删除了
        db.dropDatabase()            -- drop the current database


----------- 2016-11-09 13:35:11
$ du -sh /var/lib/mongodb/*
3.1G  /var/lib/mongodb/journal
64M /var/lib/mongodb/kidd.0
129M  /var/lib/mongodb/kidd.1
17M /var/lib/mongodb/kidd.ns
64M /var/lib/mongodb/local.0
17M /var/lib/mongodb/local.ns
64M /var/lib/mongodb/microblog.0
129M  /var/lib/mongodb/microblog.1
17M /var/lib/mongodb/microblog.ns
4.0K  /var/lib/mongodb/mongod.lock
65M /var/lib/mongodb/test.0
129M  /var/lib/mongodb/test.1
17M /var/lib/mongodb/test.ns
4.0K  /var/lib/mongodb/_tmp

-------- 2016-11-09 20:22:33
> db.col01.update({ "_id" : ObjectId("5822b0b29e54c21d76fe1049")}, { "_id" : ObjectId("5822b0b29e54c21d76fe1049"), name : "菜鸟教程2", age:12 })
> db.col01.find()
{ "_id" : ObjectId("5822b0b59e54c21d76fe104a"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b69e54c21d76fe104b"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b69e54c21d76fe104c"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b79e54c21d76fe104d"), "name" : "菜鸟教程" }
{ "_id" : ObjectId("5822b0b29e54c21d76fe1049"), "name" : "菜鸟教程2", "age" : 12 }

  when updating, the key can be without quotes. and the number value can be without quotes, but string not.
-------------- 2016-11-15 18:30:10

java


    @POST
    @Path("result")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public static JsonObject result(
            JsonObject body
    ) {
        long start = System.currentTimeMillis();

        JsonObjectBuilder builder = Json.createObjectBuilder();

        // cmd : string
        // param : array
        // data : object
        //      codeList : codes
        //      fieldList : fields
        //      timeList : times
        //      data : arrays
        //      errorCode : error status

        String cmd = body.getString("cmd");
        JsonString dataStr = body.getJsonString("data");
        // sample data
        // {"codeList":["000903.SH"],"fieldList":["OPEN","HIGH","SEC_NAME"],"timeList":["2016-11-08T00:00:00","2016-11-09T00:00:00","2016-11-10T00:00:00"],"data":[3156.0273,3172.436,"中证100",3157.6802,3162.2534,"中证100",3162.8038,3193.9868,"中证100"],"errorCode":0}
        JsonObject data = StringUtils.parseJson(dataStr.getString());
        JsonArray codeList = data.getJsonArray("codeList"); // codeList does not work if there are multiple windcodes for wsi
        JsonArray fieldList = data.getJsonArray("fieldList"); // there is a "windcode" field if there are multiple windcodes for wsi
        JsonArray timeList = data.getJsonArray("timeList");
        JsonArray dataArray = data.getJsonArray("data");
        int error = data.getInt("errorCode");
        if (error != 0) {
            logger.error("error occurred, to exit with " + error);
            return builder.build();
        }

        logger.info("cmd is: " + cmd);
        logger.info("code list size is: " + codeList.size());
        logger.info("field list size is: " + fieldList.size());
        logger.info("time list size is: " + timeList.size());
        String temp = dataArray.toString();
        // there might be different value type in dataArray
        // JsonArray does not provide any api to judge which method to call to access member
        // getJsonObject or getJsonNumber or others
        // hence parse the data string into an object array
        Object[] dataArr = temp.substring(1, temp.length()-1).split(",");
//        logger.info("recved data: " + temp);

        // before upserting, all wincode keeps upper case, and all other keys are converted to lower case
        int fieldsSize = fieldList.size();
        if (cmd.equals("wsd")) {
            String windcode = codeList.getString(0);
            for (int i = 0; i < timeList.size(); ++i) {
                Document doc = new Document();
                doc.append("windcode", windcode);
                doc.append("create_at", System.currentTimeMillis());
                Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                doc.append("date", dateLong);
                for (int j = 0; j < fieldsSize; ++j) {
                    doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                }
                MongoUtil.upsertWindWsdEntry(windcode, dateLong, doc);
            }
        } else if (cmd.equals("wsi")) {
            boolean multiple = false;
            for (int i = 0; i < fieldList.size(); ++i) {
                if (fieldList.getString(i).equals("windcode")) {
                    // there are multiple windcodes
                    multiple = true;
                    break;
                }
            }
            if (multiple) {
                for (int i = 0; i < timeList.size(); ++i) {
                    Document doc = new Document();
                    doc.append("create_at", System.currentTimeMillis());
                    Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                    doc.append("date", dateLong);
                    String windcode = "";
                    for (int j = 0; j < fieldList.size(); ++j) {
                        doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                        if (fieldList.getString(j).toLowerCase().equals("windcode")) {
                            windcode = dataArr[i * fieldsSize + j].toString();
                        }
                    }
                    MongoUtil.upsertWindWsiEntry(windcode, dateLong, doc);
                }
            } else {
                // windcode in codeList, same as wsd, but call upsertWindWsiEntry instead
                String windcode = codeList.getString(0);
                for (int i = 0; i < timeList.size(); ++i) {
                    Document doc = new Document();
                    doc.append("windcode", windcode);
                    doc.append("create_at", System.currentTimeMillis());
                    Long dateLong = TimeUtil.date2TimeStamp(timeList.getString(i).replaceFirst("T", " "), "yyyy-MM-dd HH:mm:ss");
                    doc.append("date", dateLong);
                    for (int j = 0; j < fieldList.size(); ++j) {
                        doc.append(fieldList.getString(j).toLowerCase(), dataArr[i * fieldsSize + j]);
                    }
                    MongoUtil.upsertWindWsiEntry(windcode, dateLong, doc);
                }
            }
        } else if (cmd.equals("wset")) {
            Long objId;
            if (null != body.getJsonNumber("objId")) {
                objId = body.getJsonNumber("objId").longValue();

                List<Document> docs = new ArrayList<>();
                int rows = dataArr.length / fieldsSize;
                for (int i = 0; i < rows; ++i) {
                    if (MongoUtil.hasWindWsetEntry(dataArr[i * fieldsSize + 1].toString())) {
//                        logger.info(dataArr[i * fieldsSize + 1].toString() + ": having windwset entry already");
                        Document doc = new Document();
                        doc.append("sectors", objId);
                        MongoUtil.updateWindWsetEntry(dataArr[i * fieldsSize + 1].toString(), doc);
                    } else {
//                        logger.info(dataArr[i * fieldsSize + 1].toString() + ": not having windwset entry yet");
                        Document doc = new Document();
                        doc.append("_id", MongoUtil.getNextSequence("wind_wset"));
                        List<Long> objIdArray = new ArrayList<>();
                        objIdArray.add(objId);
                        doc.append("sectors", objIdArray);
                        Long dateLong = TimeUtil.date2TimeStamp(dataArr[i * fieldsSize].toString().replaceFirst("T", " ").replace("\"", ""), "yyyy-MM-dd HH:mm:ss");
                        doc.append("date", dateLong);
                        doc.append("create_at", System.currentTimeMillis());
                        doc.append("windcode", dataArr[i * fieldsSize + 1].toString());
                        doc.append("sec_name", dataArr[i * fieldsSize + 2].toString());
                        docs.add(doc);
                    }
                }
                if (docs.size() > 0) {
                    MongoUtil.insertWindWsetEntries(docs);
                }
            } else {
                logger.error("obj id not existing for returned wset results");
            }
        }

        long end = System.currentTimeMillis();

        logger.info("spent " + (end-start) + "ms in total");

        return builder.build();
    }


    public static boolean updateWindWsetEntry(String windCode, Document doc) {
        MongoCollection<Document> col = database.getCollection(MongoUtil.WIND_WSET_COL);
        col.updateOne(eq("windcode", windCode), new Document("$addToSet", doc));
        return true;
    }

    public static boolean insertWindWsetEntries(List<Document> docs) {
        MongoCollection<Document> col = database.getCollection(MongoUtil.WIND_WSET_COL);
        col.insertMany(docs);
        return true;
    }

--------------- 2017-01-05 15:46:02
http://www.runoob.com/mongodb/mongodb-replication.html

$ mongo -host 10.12.6.43
MongoDB shell version: 2.4.9
connecting to: 10.12.6.43:27017/test
> show dbs
apes  0.953125GB
kidd  0.203125GB
local 0.078125GB
microblog 0.203125GB
test  0.203125GB
> rs.conf()
null
> rs.initiate()
{
  "info2" : "no configuration explicitly specified -- making one",
  "me" : "10.12.6.43:27017",
  "info" : "Config now saved locally.  Should come online in about a minute.",
  "ok" : 1
}
> rs.conf()
{
  "_id" : "rs0",
  "version" : 1,
  "members" : [
    {
      "_id" : 0,
      "host" : "10.12.6.43:27017"
    }
  ]
}
rs0:SECONDARY> rs.status()
{
  "set" : "rs0",
  "date" : ISODate("2017-01-05T07:44:35Z"),
  "myState" : 1,
  "members" : [
    {
      "_id" : 0,
      "name" : "10.12.6.43:27017",
      "health" : 1,
      "state" : 1,
      "stateStr" : "PRIMARY",
      "uptime" : 117,
      "optime" : Timestamp(1483602245, 1),
      "optimeDate" : ISODate("2017-01-05T07:44:05Z"),
      "self" : true
    }
  ],
  "ok" : 1
}
rs0:PRIMARY> db.isMaster()
{
  "setName" : "rs0",
  "ismaster" : true,
  "secondary" : false,
  "hosts" : [
    "10.12.6.43:27017"
  ],
  "primary" : "10.12.6.43:27017",
  "me" : "10.12.6.43:27017",
  "maxBsonObjectSize" : 16777216,
  "maxMessageSizeBytes" : 48000000,
  "localTime" : ISODate("2017-01-05T07:45:21.571Z"),
  "ok" : 1
}


------------- 2017-02-04 12:08:31 mongo.py
#!encoding=utf-8

import pymongo, datetime, time
import os
from pymongo import MongoClient
import sys
import simplejson

# print os.getenv('ENVIRONMENT', 'dev')
# connection=pymongo.MongoClient('10.12.6.6', 27017)
# # connection=pymongo.MongoClient('120.26.95.121', 27017)
# # connection=pymongo.MongoClient('10.12.0.61', 27017)
# # db=connection.apes
# db=connection.kidd
# col=db.wind_wsi

def get_information_measurements():
  info_connection=pymongo.MongoClient('10.12.6.6', 27017)
  info_db=info_connection.apes
  info_col=info_db.measures
  bak_infos = info_col.find({'type':{'$ne':0}, 'datasetId' : 'wind_information'})
  indexes = []
  for info in bak_infos:
    indexes.append(info['id'])
  return indexes

def upsert_information(windcode, doc):
  info_connection=pymongo.MongoClient('10.12.6.6', 27017)
  info_db=info_connection.test
  info_col=info_db.kidd
  info_col.update({'windcode': windcode, 'age' : 30}, {'$set': doc}, upsert=True)

def upsert_last_fail_point(spider, start, end, code):
  info_connection=pymongo.MongoClient('10.12.6.6', 27017)
  info_db=info_connection.apes
  col=info_db.last_fail_point
  doc = {
    'spider': spider,
    'start': start,
    'end': end,
    'code': code,
  }
  col.update({'spider': spider}, {'$set': doc}, upsert=True)

# 指数/股票指数类/中金指数/中金A股指数
def get_16588_codes(start_from=""):
  info_connection=pymongo.MongoClient('120.26.95.121', 3017)
  info_db=info_connection.apes
  info_col=info_db.wind_wset
  bak_infos = info_col.find({'sectors':16588})
  codes = []
  # start_from = "600640.SH"
  if start_from != "":
    flag = False
  else:
    flag = True
  for info in bak_infos:
    if not flag:
      if info['windcode'] == start_from:
        flag = True
        codes.append(info['windcode'])
      continue
    codes.append(info['windcode'])
  return codes

def upsert_wind_wsd_close(doc):
  # info_connection=pymongo.MongoClient('10.12.6.43', 27017)
  info_connection=pymongo.MongoClient('10.51.3.146', 3017)
  info_db=info_connection.apes
  info_col=info_db.wind_wsd
  time = datetime.datetime.fromtimestamp(doc['date'] / 1000)
  print 'updating ' + doc['windcode'] + 'data on ' + str(time)
  # print doc['date']
  del doc['_id']
  info_col.update({'windcode': doc['windcode'], 'date' : doc['date']}, {'$set': doc}, upsert=True)


def upsert_wind_wsi_close(doc):
  # info_connection=pymongo.MongoClient('10.12.6.43', 27017)
  info_connection=pymongo.MongoClient('10.51.3.146', 3017)
  info_db=info_connection.apes
  info_col=info_db.wind_wsi
  time = datetime.datetime.fromtimestamp(doc['date'] / 1000)
  print 'updating ' + doc['windcode'] + 'data on ' + str(time)
  # print doc['date']
  del doc['_id']
  info_col.update({'windcode': doc['windcode'], 'date' : doc['date']}, {'$set': doc}, upsert=True)

def isodate_test():
  # info_connection=pymongo.MongoClient('10.12.6.43', 27017)
  info_connection=pymongo.MongoClient('10.12.0.11', 27017)
  info_db=info_connection.test
  info_col=info_db.kidd
  ts = time.time()
  t = datetime.datetime.fromtimestamp(ts)
  doc = {'date' : t, 'windcode' : '000001.SZ'}
  info_col.update({'windcode': doc['windcode'], 'date' : doc['date']}, {'$set': doc}, upsert=True)

if __name__ == "__main__":
  # file = open("wind_wsi.dat")
  # try:
  #     # content = file.read()
  #     docs = file.readlines()
  #     print 'got ' + str(len(docs)) + ' lines'
  #     for doc in docs:
  #       upsert_wind_wsi_close(simplejson.loads(doc.replace('\n', '')))
  #       # upsert_wind_wsd_close(simplejson.loads(doc.replace('\n', '')))
  # finally:
  #     file.close()

  # file = open("wind_wsi_earlier.dat")
  # try:
  #     # content = file.read()
  #     docs = file.readlines()
  #     print 'got ' + str(len(docs)) + ' lines'
  #     for doc in docs:
  #       upsert_wind_wsi_close(simplejson.loads(doc.replace('\n', '')))
  #       # upsert_wind_wsd_close(simplejson.loads(doc.replace('\n', '')))
  # finally:
  #     file.close()

  # file = open("wind_wsd.dat")
  # try:
  #     # content = file.read()
  #     docs = file.readlines()
  #     print 'got ' + str(len(docs)) + ' lines'
  #     for doc in docs:
  #       # upsert_wind_wsi_close(simplejson.loads(doc.replace('\n', '')))
  #       upsert_wind_wsd_close(simplejson.loads(doc.replace('\n', '')))
  # finally:
  #     file.close()

  # file = open("wind_wsd_earlier.dat")
  # try:
  #     # content = file.read()
  #     docs = file.readlines()
  #     print 'got ' + str(len(docs)) + ' lines'
  #     for doc in docs:
  #       # upsert_wind_wsi_close(simplejson.loads(doc.replace('\n', '')))
  #       upsert_wind_wsd_close(simplejson.loads(doc.replace('\n', '')))
  # finally:
  #     file.close()

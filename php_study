
$ git clone https://github.com/php/php-src.git
Cloning into 'php-src'...
remote: Counting objects: 672048, done.
remote: Compressing objects: 100% (15/15), done.
Receiving objects:  95% (643793/672048), 233.82 MiB | 656.00 KiB/s




------------- 2016-09-03 17:36:41
kidd@kidd-T430:~/workspace/php$ php get.php 
PHP Fatal error:  Call to undefined function curl_init() in /home/kidd/workspace/php/get.php on line 4

You don't have curl support in your PHP. This question has been asked many times here – Shef Jun 17 '11 at 7:20 

Go to your php.ini file and remove the ; mark from the beginning of the following line:
;extension=php_curl.dll
ubuntu 13.0 and above, simply use the debundled package. In a terminal type the following to install it and do not forgot to restart server.
sudo apt-get install php-curl
Or if you're using the old PHP5
sudo apt-get install php5-curl


------- 2016-09-02 09:59:07
require()语句包括并运行指定文件。 
require() 和 include()除了怎样处理失败之外在各方面都完全一样。include() 产生一个警告而 require()则导致一个致命错误。换句话说，如果你想在丢失文件时停止处理页面，那就别犹豫了，用 require() 吧。include() 就不是这样，脚本会继续运行。同时也要确认设置了合适的include_path。 

-------- 2016-09-02 09:56:22


https://segmentfault.com/q/1010000000437998
php文件只要开始标签而不要结尾标签?

这是官方手册上推荐的用法，手册上有详细说明：

    如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。

纯 PHP 文件必须省略关闭标签、
文件末尾必须空一行。
换仿佛必须是 LF。
这就是PSR-2风格指南里的， 该指南是经过许多的开源项目风格调查之后总结的一个多数人使用的方法。 旨在让不同的 PHP 项目之间切换， 或审阅别人代码时， 能够无缝开始， 降低熟悉风格的成本。 这个风格上的所有内容都是有一定意义的，比如省略关闭标签主要是文件 include 和 输出内容不受干扰的考量。 否则很有可能在你的关闭标签后面掺杂东西到另一个文件里， 没有经验的人会很难排查错误。
www.php-fig.org
我这两天翻译个这个， yii2的风格， 基本是在psr2基础上做少许修改（缩进四个空格改为tab），https://github.com/AbrahamGreyson/yii2-zh-cn/blob/master/internals/core-code-style.md
更正下，经过激烈的讨论，yii2决定完全兼容psr2， 移除tab缩进，改为更符合社区多数人习惯的4空格缩进。
一点题外话，这仅仅是代码风格指南，最大的意义不是所有人都遵守它，而是在一个圈子内大家尽量维持一致，以便提高协作的效率，在这点上google有一篇文章专门讲公司内部代码规范的必要性。 大家支持并尊重该指南的基础是， 不搞那么多个性化，一切都按照大家约定的习惯来。 目前 PHP 已经有相当多大项目完全遵照这个风格。例如yii2 symfony2 laravel。如果你想在测试的时候集成风格的检查， 可以安装 PHP_CodeSniffer ， 他能在构建的时候给你检查风格是否符合你的设定。
另外注释是另一个范畴了， 建议你用符合 PHPdoc 规范的注释。 可以自动把你的代码生成 api 手册， 可以代替类图 uml之类的东西。 快速查询时比较方便。
    2014年03月18日回答 · 2014年03月18日更新 

----------- 2016-08-31 19:23:53
curl

    public static function upload($url, $filedata) {
        $curl = curl_init ();
        if (class_exists ( '/CURLFile' )) {//php5.5跟php5.6中的CURLOPT_SAFE_UPLOAD的默认值不同
//            curl_setopt ( $curl, CURLOPT_SAFE_UPLOAD, true );
        } else {
            if (defined ( 'CURLOPT_SAFE_UPLOAD' )) {
//                curl_setopt ( $curl, CURLOPT_SAFE_UPLOAD, false );
            }
        }
        curl_setopt ( $curl, CURLOPT_URL, $url );
        curl_setopt ( $curl, CURLOPT_SSL_VERIFYPEER, FALSE );
        curl_setopt ( $curl, CURLOPT_SSL_VERIFYHOST, FALSE );
        if (! empty ( $filedata )) {
            curl_setopt ( $curl, CURLOPT_POST, 1 );
            curl_setopt ( $curl, CURLOPT_POSTFIELDS, $filedata );
        }
        curl_setopt ( $curl, CURLOPT_RETURNTRANSFER, 1 );
        $output = curl_exec ( $curl );
        curl_close ( $curl );
        return $output;

    }

    private function http_post_media($url,$strPOST)
    {
        $oCurl = curl_init ();
//        curl_setopt ( $oCurl, CURLOPT_SAFE_UPLOAD, false);
//        curl_setopt($oCurl, CURLOPT_POSTFIELDS, array(
//            'file' => '@'.realpath('image.png'),
//        ));

        if (stripos ( $url, "https://" ) !== FALSE) {
            curl_setopt ( $oCurl, CURLOPT_SSL_VERIFYPEER, FALSE );
            curl_setopt ( $oCurl, CURLOPT_SSL_VERIFYHOST, false );
        }

        curl_setopt ( $oCurl, CURLOPT_URL, $url );
        curl_setopt ( $oCurl, CURLOPT_RETURNTRANSFER, 1 );
        curl_setopt ( $oCurl, CURLOPT_POST, true );
        curl_setopt ( $oCurl, CURLOPT_POSTFIELDS, $strPOST );
        $sContent = curl_exec ( $oCurl );
        $aStatus = curl_getinfo ( $oCurl );
        curl_close ( $oCurl );
        if (intval ( $aStatus ["http_code"] ) == 200) {
            return $sContent;
        } else {
            return false;
        }

    }

----------- 2016-08-31 17:16:04
differences between self and static:
http://www.jb51.net/article/68754.htm

---------- 2016-08-31 16:27:45
to delete a file:
 $result = @unlink($full_file_path);

----------- 2016-08-31 14:33:56
obtain runtime path:
  http://www.kuitao8.com/20141102/3208.shtml

return Yii::$app->runtimepath;
  /home/kidd/workspace/bc/advanced/MissionImpossible/frontend/runtime

class Yii extends \yii\BaseYii
class BaseYii
{
    /**
     * @var \yii\console\Application|\yii\web\Application the application instance
     */
    public static $app;

/home/kidd/workspace/bc/advanced/MissionImpossible/vendor/yiisoft/yii2/base/Application.php
abstract class Application extends Module
 * @property string $runtimePath The directory that stores runtime files. Defaults to the "runtime"


---------- 2016-08-31 14:15:51
https://mp.weixin.qq.com/wiki/11/c88c270ae8935291626538f9c64bd123.html

http://frontend.tz8/test/send-image
http://frontend.tz8/test/send-text

/home/kidd/workspace/bc/advanced/MissionImpossible/frontend/controllers/TestController.php
    public function actionSendText()
    {
        if (!YII_ENV_PROD) {
            if(Wechat::postTextToUser("ook-7wLch8xSS-mM-urjLCCs91n0", "afternoon anhua, again")) return "true";
            else return "false";
        }
    }
    public function actionSendImage()
    {
        if (!YII_ENV_PROD) {
            if(Wechat::postImageToUser("ook-7wLch8xSS-mM-urjLCCs91n0", "wXFdY0s3osL-_rZxv7xJICUeB7xdDa6kJQWwIi8IXGjmXe1G4zclcmTIv-wfMJgH")) return "true";
            else return "false";
        }
    }

-------- 2016-08-31 13:39:44

yii:

public function actionDownloadImage() {
    if(!YII_ENV_PROD) {
        return __DIR__;
    }
}

/home/kidd/workspace/bc/advanced/MissionImpossible/frontend/controllers

    public function actionDownloadImage() {
        if(!YII_ENV_PROD) {
            $url = "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGB7zoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2h6dHVvVlhsMmp5alBhc1ZDaFZtAAIEJFzGVwMEAI0nAA==";
            $full_file_path = "/home/kidd/workspace/bc/advanced/MissionImpossible/frontend/runtime/images/test.jpg";
            Util::curl_get_image($url, $full_file_path);
            return __DIR__;
        }
    }
~/workspace/bc/advanced/MissionImpossible/frontend/runtime
$ ll images/
total 48
drwxrwxr-x 2 www-data www-data  4096  8月 31 13:46 ./
drwxrwxrwx 7 kidd     kidd      4096  8月 31 13:45 ../
-rw-r--r-- 1 www-data www-data 37962  8月 31 13:46 test.jpg


    public function actionDownloadImage() {
        if(!YII_ENV_PROD) {
            $url = "https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGB7zoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2h6dHVvVlhsMmp5alBhc1ZDaFZtAAIEJFzGVwMEAI0nAA==";
            $filename = uniqid(date("Y_m_d_H_i_s_")).".jpg";
            $full_file_path = "/home/kidd/workspace/bc/advanced/MissionImpossible/frontend/runtime/images/".$filename;
            Util::curl_get_image($url, $full_file_path);
            return Wechat::postImageToServer($full_file_path);
        }
    }

https://mp.weixin.qq.com/wiki/10/78b15308b053286e2a66b33f0f0f5fb6.html
正确情况下的返回JSON数据包结果如下：
{"type":"TYPE","media_id":"MEDIA_ID","created_at":123456789}

response:
    "{\"type\":\"image\",\"media_id\":\"jnRmmoNh0G1LoxVeUzs9HLOvzVk7dsYis9ejpNwhjo73k1pjXafJmZucVU9aoiwG\",\"created_at\":1472622961}"

verification:
http请求方式: GET
http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID
请求示例（示例为通过curl命令获取多媒体文件）
curl -I -G "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=ACCESS_TOKEN&media_id=MEDIA_ID"

  $url = "http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=$mpAccessToken&media_id=".$arr['media_id'];
  return $url;
  http://file.api.weixin.qq.com/cgi-bin/media/get?access_token=i1Jxxi5TsEVUg15GxUtHfBcoQm3uXMBssCptUaZI3lUKIshOcJ_EhuXKACR5FQkXegP5nN7PwWFAPsaOQ1_CcB6tJnKkb04-EY16W4jk2JPdli1vt4QrpgTj0sJ75XwUYVRbADATQM&media_id=wXFdY0s3osL-_rZxv7xJICUeB7xdDa6kJQWwIi8IXGjmXe1G4zclcmTIv-wfMJgH

----------- 2016-08-31 13:33:04
http://www.php100.com/html/php/lei/2013/0905/5393.html
  php使用curl来获取远程图片
<?php
function getImg($url = "", $filename = "")
{
 //去除URL连接上面可能的引号
  //$url = preg_replace( '/(?:^['"]+|['"/]+$)/', '', $url );
  $hander = curl_init();
  $fp = fopen($filename,'wb');
  curl_setopt($hander,CURLOPT_URL,$url);
  curl_setopt($hander,CURLOPT_FILE,$fp);
  curl_setopt($hander,CURLOPT_HEADER,0);
  curl_setopt($hander,CURLOPT_FOLLOWLOCATION,1);
  //curl_setopt($hander,CURLOPT_RETURNTRANSFER,false);//以数据流的方式返回数据,当为false是直接显示出来
  curl_setopt($hander,CURLOPT_TIMEOUT,60);
  curl_exec($hander);
  curl_close($hander);
  fclose($fp);
  Return true;
}
getImg("https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=gQGB7zoAAAAAAAAAASxodHRwOi8vd2VpeGluLnFxLmNvbS9xL2h6dHVvVlhsMmp5alBhc1ZDaFZtAAIEJFzGVwMEAI0nAA==", __DIR__."/tmp/test.jpg");
?>
~/workspace/php
$ tree tmp
tmp
└── test.jpg

--------------- 2016-08-30 16:05:15
php -S

The development web server built in to PHP 5.4+ does not work in the way you want. That is, it's not a PHP process, and you can't have it run code for you.

It's designed to serve PHP applications and content from the specified directory. The output of the server process is the access log. You can write to the log using the error_log function, with a value of 4 as the message_type. 

------- 2016-08-26 19:05:28

$b = new test\test\Inside();
echo get_class($b)."\n";

if a class under the same ns is declared twice, there will be below error:
$ php test.php
PHP Fatal error:  Cannot declare class test\Inside, because the name is already in use in /home/kidd/workspace/php/composer/Http/File/Interface.php on line 17
PHP Stack trace:
PHP   1. {main}() /home/kidd/workspace/php/composer/test.php:0
PHP   2. require_once() /home/kidd/workspace/php/composer/test.php:67

在PHP开发过程中，如果希望从外部引入一个class，通常会使用include和require方法，去把定义这个class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，这么做会产生大量的require或者include方法调用，这样不因降低效率，而且使得代码难以维护，况且require_once的代价很大。

在PHP5之前，各个PHP框架如果要实现类的自动加载，一般都是按照某种约定自己实现一个遍历目录，自动加载所有符合约定规则的文件的类或函数。 当然，PHP5之前对面向对象的支持并不是太好，类的使用也没有现在频繁。 在PHP5后，当加载PHP类时，如果类所在文件没有被包含进来，或者类名出错，Zend引擎会自动调用__autoload 函数。此函数需要用户自己实现__autoload函数。 在PHP5.1.2版本后，可以使用spl_autoload_register函数自定义自动加载处理函数。当没有调用此函数，默认情况下会使用SPL自定义的spl_autoload函数。

---------- 2016-08-26 18:03:07

要注意的是，当前脚本文件的第一个命名空间前面不能有任何代码
为什么要说第一个命名空间呢？因为同一脚本文件中可以创建多个命名空间。

在说别名和导入之前，需要知道关于空间三种名称的术语，以及PHP是怎样解析它们的。官方文档说得非常好，我就直接拿来套了。
1.非限定名称，或不包含前缀的类名称，例如 $comment = new Comment();。如果当前命名空间是Blog\Article，Comment将被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。
2.限定名称，或包含前缀的名称，例如 $comment = new Article\Comment();。如果当前的命名空间是Blog，则Comment会被解析为Blog\Article\Comment。如果使用Comment的代码不包含在任何命名空间中的代码（全局空间中），则Comment会被解析为Comment。
3.完全限定名称，或包含了全局前缀操作符的名称，例如 $comment = new \Article\Comment();。在这种情况下，Comment总是被解析为代码中的文字名(literal name)Article\Comment。
其实可以把这三种名称类比为文件名（例如 comment.php）、相对路径名（例如 ./article/comment.php）、绝对路径名（例如 /blog/article/comment.php），这样可能会更容易理解。

http://php.net/manual/zh/language.namespaces.rules.php

namespace test;
spl_autoload_register(function($class){
  if($class == 'Http_File_Interface'){
    require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  }
});
spl_autoload_register(function($class){
  if($class == 'test\Inter') {
    require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  }
});
$a = new Inter();
$a->name();

in below code, "test\test\Inside" is still in the hello namespace, which means the namespace defined in Interface.php does not affect following code. Even put some "use" clauses in Interface.php does not affect the naming logic in the following code.
  namespace hello;
  require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  $b = new test\test\Inside();


导入规则is in effect only when it is in the "use" clause;
Example #1 名称解析示例
<?php
namespace A;
use B\D, C\E as F;
// 函数调用
foo();      // 首先尝试调用定义在命名空间"A"中的函数foo()
            // 再尝试调用全局函数 "foo"
\foo();     // 调用全局空间函数 "foo" 
my\foo();   // 调用定义在命名空间"A\my"中函数 "foo" 
F();        // 首先尝试调用定义在命名空间"A"中的函数 "F" 
            // 再尝试调用全局函数 "F"
// 类引用
new B();    // 创建命名空间 "A" 中定义的类 "B" 的一个对象
            // 如果未找到，则尝试自动装载类 "A\B"
new D();    // 使用导入规则，创建命名空间 "B" 中定义的类 "D" 的一个对象
            // 如果未找到，则尝试自动装载类 "B\D"
new F();    // 使用导入规则，创建命名空间 "C" 中定义的类 "E" 的一个对象
            // 如果未找到，则尝试自动装载类 "C\E"
new \B();   // 创建定义在全局空间中的类 "B" 的一个对象
            // 如果未发现，则尝试自动装载类 "B"
new \D();   // 创建定义在全局空间中的类 "D" 的一个对象
            // 如果未发现，则尝试自动装载类 "D"
new \F();   // 创建定义在全局空间中的类 "F" 的一个对象
            // 如果未发现，则尝试自动装载类 "F"
// 调用另一个命名空间中的静态方法或命名空间函数
B\foo();    // 调用命名空间 "A\B" 中函数 "foo"
B::foo();   // 调用命名空间 "A" 中定义的类 "B" 的 "foo" 方法
            // 如果未找到类 "A\B" ，则尝试自动装载类 "A\B"
D::foo();   // 使用导入规则，调用命名空间 "B" 中定义的类 "D" 的 "foo" 方法
            // 如果类 "B\D" 未找到，则尝试自动装载类 "B\D"
\B\foo();   // 调用命名空间 "B" 中的函数 "foo" 
\B::foo();  // 调用全局空间中的类 "B" 的 "foo" 方法
            // 如果类 "B" 未找到，则尝试自动装载类 "B"
// 当前命名空间中的静态方法或函数
A\B::foo();   // 调用命名空间 "A\A" 中定义的类 "B" 的 "foo" 方法
              // 如果类 "A\A\B" 未找到，则尝试自动装载类 "A\A\B"
\A\B::foo();  // 调用命名空间 "A\B" 中定义的类 "B" 的 "foo" 方法
              // 如果类 "A\B" 未找到，则尝试自动装载类 "A\B"
?>


------------- 2016-08-26 17:06:41

实例化一个类的时候，如果文件中不包括类文件，就会调用__autoload函数去加载类库文件。
最经常使用的就是这种方法，根据类名，找出类文件，然后require_once
http://www.jb51.net/article/31399.htm

1. 这种方法的好处就是简单易使用。当然也有缺点，缺点就是将类名和文件路径强制做了约定，当修改文件结构的时候，就势必要修改类名。 
function __autoload($class_name) {
  echo "trying autoloading $class_name\n";
  $path = str_replace('_', '/', $class_name);
  require_once $path . '.php';
}
// 这里会自动加载Http/File/Interface.php 文件
$a = new Http_File_Interface();
$a->name();

2. 这种方法的好处就是类名和文件路径只是用一个映射来维护，所以当文件结构改变的时候，不需要修改类名，只需要将映射中对应的项修改就好了。 
这种方法相较于前面的方法缺点是当文件多了的时候这个映射维护起来非常麻烦，或许这时候你就会考虑使用json或者单独一个文件来进行维护了。或许你会想到使用一个框架来维护或者建立这么一个映射。
$map = array(
  'Http_File_Interface' => '/home/kidd/workspace/php/composer/Http/File/Interface.php'
);
function __autoload($class_name) {
  global $map;
  if (isset($map[$class_name])) {
    require_once $map[$class_name];
  }
  else {
    echo "not found\n";
  }
}
// 这里会自动加载Http/File/Interface.php 文件
$a = new Http_File_Interface();
$a->name();

__autoload的最大缺陷是无法有多个autoload方法 

如果你的PHP版本大于5.1的话，你就可以使用spl_autoload 


3. (PHP 5 >= 5.1.2)
http://www.jb51.net/article/88816.htm
将__autoload换成loadprint函数。但是loadprint不会像__autoload自动触发，这时spl_autoload_register()就起作用了，它告诉PHP碰到没有定义的类就执行loadprint()。
$map = array(
  'Http_File_Interface' => '/home/kidd/workspace/php/composer/Http/File/Interface.php'
);
function loadprint($class_name) {
  global $map;
  if (isset($map[$class_name])) {
    require_once $map[$class_name];
  }
  else {
    echo "not found\n";
  }
}
spl_autoload_register('loadprint');
// 这里会自动加载Http/File/Interface.php 文件
$a = new Http_File_Interface();
$a->name();

spl_autoload_register() 调用静态方法
  spl_autoload_register( array('test','loadprint') );
  class test {
    public static function loadprint( $class )

bool spl_autoload_register ([ callback $autoload_function ] )
将函数注册到SPL __autoload函数栈中。如果该栈中的函数尚未激活，则激活它们。

如果在你的程序中已经实现了__autoload函数，它必须显式注册到__autoload栈中。因为spl_autoload_register()函数会将Zend Engine中的__autoload函数取代为spl_autoload() 或 spl_autoload_call()。

spl_autoload_register(function($class){
  echo "hello";
  if($class == 'Http_File_Interface'){
    require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  }
});
$a = new Http_File_Interface();
$a->name(); 


Interface.php:
<?php 

  class Inter {
    public function name() {
      echo "http file inter\n";
    }
  }
  class Http_File_Interface {
    public function name() {
      echo "http file Http_File_Interface\n";
    }
  }

?>

test.php
spl_autoload_register(function($class){
  if($class == 'Http_File_Interface'){
    require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  }
});
spl_autoload_register(function($class){
  if($class == "Inter") {
    require_once("/home/kidd/workspace/php/composer/Http/File/Interface.php");
  }
});
$a = new Inter();
$a->name();

-------- 2016-08-26 16:12:32
composer 

第一件事情在composer.json就是使用require关键字了，你将告诉composer哪些包是你项目所需要的
{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
基本上包的命名是 主名/项目名称（ monolog/monolog），主名必须唯一，但是项目也就是我们的包的名称可以有相同的，例如: igorw/json,和seldaek/json
我们需要使用monolog的版本是1.0.*，他的意思是只要版本是1.0分支即可，例如1.0.0，1.0.2或者1.0.99
版本定义的两种方式：
    标准的版本：定义保准的版本包文件，如：1.0.2
    一定范围的版本：使用比较符号来定义有效的版本的范围，有效的符号有>, >=, <,<=, !=
    通配符：特别的匹配符号*，例如1.0.*就相当于>=1.0,<1.1版本的即可
    下一个重要的版本：~符号最好的解释就是，~1.2就相当于>1.2,<2.0，但~1.2.3就相当于>=1.2.3,<1.3版本。  
在项目文件路径下运行
$ composer install
这样子他会自动下载monolog/monolog文件到你的vendor目录下面。
 
接下来需要说明一件事情就是
    composer.lock - 锁定文件
在安装完所有需要的包之后，composer会生成一张标准的包版本的文件在composer.lock文件中。这将锁定所有包的版本。
    使用composer.lock（当然是和composer.json一起）来控制你的项目的版本
这一点非常的重要，我们使用install命令来处理的时候，它首先会判断composer.lock文件是否存在，如果存在，将会下载相对应的版本(不会在于composer.json里面的配置)，这意味着任何下载项目的人都将会得到一样的版本。
如果不存在composer.lock，composer将会通过composer.json来读取需要的包和相对的版本，然后创建composer.lock文件
这样子就可以在你的包有新的版本之后，你不会自动更新了，升级到新的版本，使用update命令即可，这样子就能获取最新版本的包并且也更新了你的composer.lock文件。
$ php composer.phar update
或者
$ composer update

Packagist是composer的主要仓库
composer仓库的基础是包的源码，你可以随意的获取，Packagist的目的建成一个任何人都可以使用的仓库，这就意味着在你的文件中任意的require包了。

to user Monolog without autoload:

$ cat composer.json 
{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}

<?php

require("vendor/monolog/monolog/src/Monolog/Logger.php");
require("vendor/monolog/monolog/src/Monolog/Handler/HandlerInterface.php");
require("vendor/monolog/monolog/src/Monolog/Formatter/FormatterInterface.php");
require("vendor/monolog/monolog/src/Monolog/Formatter/LineFormatter.php");

require("vendor/monolog/monolog/src/Monolog/Handler/AbstractHandler.php");
require("vendor/monolog/monolog/src/Monolog/Handler/AbstractProcessingHandler.php");
require("vendor/monolog/monolog/src/Monolog/Handler/StreamHandler.php");

$log = new Monolog\Logger('name');
$log->pushHandler(new Monolog\Handler\StreamHandler('app.log', Monolog\Logger::WARNING));
                                 
$log->addWarning('Foo');

?>

$ tree
.
├── app.log -> the genrated log file
├── composer.json
├── composer.lock
├── test.php
└── vendor

or

$loader = require 'vendor/autoload.php';
$loader->add('Monolog\Logger', __DIR__);

$log = new Monolog\Logger('name');
$log->pushHandler(new Monolog\Handler\StreamHandler('app.log', Monolog\Logger::WARNING));
                                 
$log->addWarning('Foo');

------------ 2016-08-25 18:10:04
php 字符串 以什么开头 以什么结尾 startWith endWith
星期一, 2013-10-07 13:40 — shipingzhong

//第一个是原串,第二个是 部份串
function startWith($str, $needle) {

    return strpos($str, $needle) === 0;

}

//第一个是原串,第二个是 部份串
 function endWith($haystack, $needle) {   

      $length = strlen($needle);  
      if($length == 0)
      {    
          return true;  
      }  
      return (substr($haystack, -$length) === $needle);
 }


----------- 2016-08-07 20:57:56
http://blog.csdn.net/th362cn/article/details/8575344
PHP数组添加一个元素的方式： push(), arr[], 
    而且有实验证明，第二种方法的效率比第一种方法高出将近一倍！
    
<?php

 $t = microtime(true);
$array = array();
for($i = 0; $i < 10000; $i++) {
$array[] = $i;
}
print microtime(true) - $t;
print '<br>';
$t = microtime(true);
$array = array();
for($i = 0; $i < 10000; $i++) {
array_push($array, $i);
}
print microtime(true) - $t;


?>



----------- 2016-08-24 16:50:18

$body = "<xml><ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[FromUser]]></FromUserName>
  <CreateTime>123456789</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[subscribe]]></Event>
  <EventKey><![CDATA[]]></EventKey>
  <Ticket><![CDATA[TICKET]]></Ticket>
  </xml>";
$xml = simplexml_load_string($body);

$temp = $xml->EventKey;
echo "EventKey is of type: ".get_class($temp)."\n";

$ php test.php
EventKey is of type: SimpleXMLElement

------- 2016-08-24 16:15:18
if(empty($test)) {
  echo "empty";
}
else {
  echo "not empty";
}

empty is true if $test is one of below: "", 0, null, false
劝告各位，千万注意使用empty()函数。
判断字符串是否为空，可以这么判断： if ($value=="") ...
* 格式：bool empty ( mixed var )
* 功能：检查一个变量是否为空
* 返回值：
* 若变量不存在则返回 TRUE
* 若变量存在且其值为""、0、"0"、NULL、、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 TURE
* 若变量存在且值不为""、0、"0"、NULL、、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 FALSE
* 版本：PHP 3, PHP 4, PHP 5

class Foo {
    protected $_date = '2014-07-21';

    public function __get($name) {
        $name = '_'.$name;
        return $this->$name;
    }
}
function is_empty($val) { return empty($val); }
$foo = new Foo();
echo $foo->date;  // 这里确实输出了日期值
if (empty($foo->date))
    echo "date is empty";
else
    echo "date is not empty";

if ( is_empty($foo->date))
    echo "date is empty";
else
    echo "date is not empty";

output:
2014-07-21date is emptydate is not empty

因为empty不是函数
使用is_empty的时候触发的是__get魔术方法，而empty触发的是__isset
http://php.net/manual/zh/language.oop5.overloading.php#object.isset 

empty是语言结构
使用is_empty的时候触发的是__get魔术方法，而empty触发的是__isset

    public function __isset($name) {
        $name = '_'.$name;
        return !empty($name);
    }

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Object.php
    /**
     * Checks if a property is set, i.e. defined and not null.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `isset($object->property)`.
     *
     * Note that if the property is not defined, false will be returned.
     * @param string $name the property name or the event name
     * @return boolean whether the named property is set (not null).
     * @see http://php.net/manual/en/function.isset.php
     */
    public function __isset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        } else {
            return false;
        }
    }

http://php.net/manual/en/function.empty.php
When using empty() on inaccessible object properties, the __isset() overloading method will be called, if declared. 

------------ 2016-08-24 15:12:44
without __isset, an attribute will be treated as empty by default. But a public member is not empty if it is set.

当对一个不可见的对象属性使用 empty() 时， __isset() 方法如果存在的话，它将会被调用。  

class Zend_Session_Namespace
{
  public $public_attr;
  private $parent_obj;
  private $session_key;
  public function __construct($params='')
  {
      $this->parent_obj=isset($_SESSION[$params])?(object)$_SESSION[$params]:new stdClass();
      $this->session_key=$params;
  }
  public function __get($name)
  {
      // TODO: Implement __get() method.
      if(isset($this->parent_obj->$name))
      {
          return($this->parent_obj->$name);
      }
      else
      {
          return(NULL);
      }
  }
  public function __set($name, $value)
  {
      // TODO: Implement __set() method.
      $this->parent_obj->$name = $value;
      $_SESSION[$this->session_key][$name]=$value;
  }
  //这个是后来加上的，加上这个，结果才对
  // public function __isset($name)
  // {
  //     return isset($this->parent_obj->$name);
  // }
}

echo "---------------";
$z = new Zend_Session_Namespace();

$z->public_attr = 'yeshello';
if(!empty($z->public_attr))
  echo "\n".strlen($z->public_attr);
else {
  echo "\n"."empty";
}


$z->parent_obj = 'yeshello';
if(!empty($z->parent_obj))
  echo "\n".strlen($z->parent_obj);
else {
  echo "\n"."empty";
}




------- 2016-08-24 11:32:26

PHP 5.3 ereg() 无法正常使用，提示“Function ereg() is deprecated Error”。
问题根源是php中有两种正则表示方法，一个是posix，一个是perl，php6打算废除posix的正则表示方法所以后来就加了个preg_match。此问题解决办法很简单，在ereg前加个过滤提示信息符号即可：把ereg()变成@ereg()。这样屏蔽了提示信息，但根本问题还是没有解决，php在5.2版本以前ereg都使用正常，在5.3以后，就要用preg_match来代替ereg。所以就需要变成这样。

原来：ereg("^[0-9]*$",$page)变成：preg_match("/^[0-9]*$/",$page)

特别提醒：posix与perl的很明显的表达区别就是是否加斜杠，所以与ereg相比，后者在正则的前后分别增加了两个"/"符号，不能缺少。

e.g., 

function valid_email($address) {
  // check an email address is possibly valid

  if (ereg('^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$', $address))
  =>
  if (preg_match('/^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$/', $address))

---------- 2016-08-23 17:51:13
error_log:  

/var/log/php
$ subl error.log 


--------- 2016-08-23 14:22:09
http://www.cnblogs.com/wlgaojin/p/4684627.html
使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类：
使用 static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。
静态绑定是PHP 5.3.0，增加的一个功能 用于在继承范围内引用静态调用的类
self refers to the same class whose method the new operation takes place in.
static in PHP 5.3's late static bindings refers to whatever class in the hierarchy which you call the method on.

class Person
{
    public static function name()
    {
        echo "xiaosan";
    }
    public static function callself()
    {
        self::name();
    }

    public static function callstatic()
    {
        static::name();
    }
}

class Man extends Person
{
    public static function name()
    {
        echo "gaojin";
    }
}
Man::name();  // output： gaojin
Man::callself();  // output： xiaosan
Man::callstatic();  // output：xiaosan(子类调用 你懂的）

output:
  gaojinxiaosangaojin
---------- 2016-08-23 14:07:13
http://11463531.blog.hexun.com/81211052_d.html
this是指向当前对象的指针（可以看成C里面的指针），self是指向当前类的指针，parent是指向父类的指针。
parent是指向父类的指针，一般我们使用parent来调用父类的构造函数。
  parent::__construct( "PBPHome");    //使用parent调用了父类的构造函数 语句①
一般self使用来指向类中的静态变量。假如我们使用类里面静态（一般用关键字static）的成员，我们也必须使用self来调用。还要注意使用self来调用静态变量必须使用:: (域运算符号) self::$firstCount


------------ 2016-08-23 11:41:34
class A {
  public $age = 9;
  public static $array = array('localhost', '127.0.0.1', 'user', 'pwd');  
  const arr = array('localhost', '127.0.0.1', 'user', 'pwd');

  // get calling method name
  private static function getCallingMethodName() {
      $debug_trace = debug_backtrace();
      if ($debug_trace && count($debug_trace) > 2) {
          $class = isset($debug_trace[2]['class']) ? $debug_trace[2]['class'] : "GlobalFunction";
          return self::DEFAULT_CATEGORY_PREFIX . $class . '::' . $debug_trace[2]['function'];
      } else {
          return self::DEFAULT_CATEGORY_PREFIX . 'shit happens';
      }
  }

  public function test() {
    $debug_trace = debug_backtrace();
    echo json_encode($debug_trace);
  }

  public function inner() {
    $this->test();
  }

  public function outer() {
    $this->inner();
  }
}

[
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 25,
        "function": "test",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    },
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 29,
        "function": "inner",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    },
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 41,
        "function": "outer",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    }
]

--------- 2016-08-23 11:21:24
$array=array('nihao','key'=>'chile');

echo "{$array['key']}"; // 花括号中的当作变量在使用进行解析处理

echo $array['key'];

$a='key';
echo "$array[$a]";

花括号并不是用来表示变量的，只是用来防止歧义

1.简单句法规则（用花括号界定变量名，适用于PHP所有版本）：
不管{是出现在$前面还是后面，只有两者紧挨着时花括号才会被当成是界定符号。不要在之间加空格，要不然就会被当作普通的花括号处理
echo "She received some { $a}s";
// 输出的结果为：She received some { flower}s
2.复杂句法规则（用花括号界定表达式等，使用与PHP4+）：
echo "有效的写法： {$arr[4][3]}";
// 有效；界定多维数组
echo "有效的写法： {$arr['foo'][3]}";
// 有效；当在字符串中使用多维数组时，一定要用括号将它括起来
echo "有效的写法： {$this->width}00";
// 有效；如果不界定的话，就会变成 $this->width00
echo "有效的写法： {$this->value[3]->name}";
// 有效；该例演示了界定链式调用
echo "有效的写法： $name: {${$name}}";
// 有效；该例演示的效果实际上是一个可变变量
echo "有效的写法: {${getName()}}";
// 有效；该例演示了将函数的返回值作为变量名
echo "有效的下发： {${$this->getName()}}";
// 有效；该例演示了将函数的返回值作为变量名
注意1：echo "这样写有效吗： {getName()}";输出结果为：'这样写有效吗：
{getName()}'。因为里面不含$，所以花括号不会被当作界定符
注意2：echo "这样写有效吗：{$arr[foo][3]}"; 在回答这个问题前我们先来进行一个实验：
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd'=>'e');
echo "This is $arr[d]";
// 我们发现这样写是没有问题的，那么我们像下面这样写呢？
echo $arr[d];
产生了这样的错误：
Notice: Use of undefined constant d - assumed 'd'
注意：采用了未定义的常量d，可能应该为'd'
那么如果我们像下面这样修改一下代码的话
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd'=>'e');
define('f', 'd');
echo $arr[f];
我们发现这次没有问题了。可以看出在字符串中数组的索引不加单引号是没有问题的，但是如果这种写法不是出现在字符串当中就会报错，而对于字符串中{$arr[foo][3]}的解析就是按照非字符串的方式解析的。所以说在字符串当中对数组只加花括号界定而不对索引加单引号的写法是错误的。因为程序会把不加单引号的索引当作是常量来进行解析，这就产生了错误。正确的写法应该是：
echo "有效的写法： {$arr['foo'][3]}";
特别提醒一点：echo "This is $arr[d]";这种写法虽然能够被程序解析，但这也仅限于数组是一维数组的情况。严谨的写法应该是：echo "This is {$arr['d']}";我的学生曾经在这一点上和我争论过，他说：既然前面一种写法能出结果，为什么一定要用后面一种写法呢？那么，我们再继续修改一下前面的代码
error_reporting(E_ALL);
$arr = array('a', 'b', 'c',
'd'=>array('e'=>'f')
);
echo "This is $arr[d][e]";
这样还能够被正确解析吗？我只想告诉你，加花括号是严谨的必要的。

注意3：
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd');
echo "This is {$arr[2]} 
";
echo "This is {$arr['2']} 
";
执行上面的代码。结果是一样的，为什么会这样呢？我只能告诉你PHP是弱类型语言，至于什么叫弱类型语言我就不在这里多说了。自己去Google一下吧。说了这么多，那么最能体现这些句法规则优势的具体应用在什么地方呢？----SQL语句
// 示例一：
$SQL1 = "select * from table where id={$_GET['id']}";
// 示例二：
$SQL2 = "select * from table where id={$this->id}";

----------- 2016-08-23 11:11:22
如果将一个字符串强制转换成一个数字.PHP会去搜索这个字符串的开头.如果开头是数字就转换.
逗号分隔开的就相当于是N个参数.也就是说把echo当个函数用.

http://php.net/manual/en/function.echo.php
// Strings can either be passed individually as multiple arguments or
// concatenated together and passed as a single argument
echo 'This ', 'string ', 'was ', 'made ', 'with multiple parameters.', chr(10);
echo 'This ' . 'string ' . 'was ' . 'made ' . 'with concatenation.' . "\n";

A benefit to passing in multiple arguments over using concatenation in echo regards the precedence of the period operator in PHP.

 With concatenation, the period operator has a higher precedence than both the addition and ternary operators, and so parentheses must be used for the correct behaviour:
<?php
echo 'Sum: ' . (1 + 2);
echo 'Hello ' . (isset($name) ? $name : 'John Doe') . '!';

----------- 2016-08-23 11:00:44
如下4种方式，都能得到同样的结果，但是，只有第4种方式是最好的。
$foo = 'John SMITH';
echo "Hello $foo, welcome on my website.";
echo "Hello " . $foo . " welcome on my website.";
echo 'Hello ' . $foo . ' welcome on my website.';
echo 'Hello ', $foo , ' welcome on my website.';

---------- 2016-08-22 11:59:20
json_encode (activerecord)
  is not as normal array. be careful.

e.g., if there is 1 ele, the output might be [{}]

use yii\helpers\Json;
Logger::info("uncheckedusers: ".Json::encode($period_mission->uncheckusers));
2016-08-22 12:07:38 [194][info][abc\app\components\MissionManager::getPeriodMissionCommonParam] uncheckedusers: [{"id":11,"account_type":"weixin","account_id":194,"nickname":"叶安华","username":"叶安华","passwd":null,"head_img":"http://wx.qlogo.cn/mmopen/PiajxSqBRaEJkp2ibNelHjpXwSUzqSaUIVRJ8Lxd9HtLDxMic2ziasKXY52oW5RLNLEH203qBoXUiavuZsp0aDnGGtQ/0","gender":1,"birthday":null,"phone":null,"regist_time":"2016-08-09 14:34:05","announce":null,"province":null,"city":null,"country":null,"updated_at":"2016-08-09 14:34:05","balance":0}]

----------- 2016-08-19 19:19:15

class A {
  public $age = 9;
}



$a = new A();
// var_dump(get_object_vars($a));
echo json_encode(get_object_vars($a));

------------ 2016-08-19 11:12:26
array:
  never use this: array([XXXXX]); this is not a simple array.

        $user_status = array(
            UserStatus::CANT_JOIN => false,
            UserStatus::CAN_JOIN => false,
            UserStatus::WAIT_CHECKIN => false,
            UserStatus::CAN_CHECKIN => false,
            UserStatus::ALREADY_CHECKIN => false,
            UserStatus::WAIT_REWARD => false,
            UserStatus::CAN_REWARD => false,
            UserStatus::CANT_REWARD => false,
            UserStatus::ALREADY_REWARD => false,
        );


---------- 2016-08-18 17:40:48

$now = time();
$count_down['next_time'] = date('Y-m-d 00:00:00', $now + 86400);

echo $count_down['next_time']."\n";

output:
  2016-08-19 00:00:00


-------- 2016-08-17 14:26:59
php property:

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Object.php
    /**
     * Returns the value of an object property.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$value = $object->property;`.
     * @param string $name the property name
     * @return mixed the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is write-only
     * @see __set()
     */
    public function __get($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter();
        } elseif (method_exists($this, 'set' . $name)) {
            throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name);
        } else {
            throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);
        }
    }


class Component extends Object
class Model extends Component implements IteratorAggregate, ArrayAccess, Arrayable
abstract class BaseActiveRecord extends Model implements ActiveRecordInterface
class ActiveRecord extends BaseActiveRecord
class Mission extends \yii\db\ActiveRecord


/home/kidd/workspace/bc/MissionImpossible/models/PeriodMission.php
    public function getStop_time()
    {
        return date('Y-m-d H:i:s', strtotime($this->start_time) + $this->repeat * $this->period * 86400);
    }

------------ 2016-08-17 14:06:45
php event

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Component.php
    /**
     * Triggers an event.
     * This method represents the happening of an event. It invokes
     * all attached handlers for the event including class-level handlers.
     * @param string $name the event name
     * @param Event $event the event parameter. If not set, a default [[Event]] object will be created.
     */
    public function trigger($name, Event $event = null)
    {
        $this->ensureBehaviors();
        if (!empty($this->_events[$name])) {
            if ($event === null) {
                $event = new Event;
            }
            if ($event->sender === null) {
                $event->sender = $this;
            }
            $event->handled = false;
            $event->name = $name;
            foreach ($this->_events[$name] as $handler) {
                $event->data = $handler[1];
                call_user_func($handler[0], $event);
                // stop further handling if the event is handled
                if ($event->handled) {
                    return;
                }
            }
        }
        // invoke class-level attached handlers
        Event::trigger($this, $name, $event);
    }

--------- 2016-08-17 14:05:11 __get
  class test{
    public function getName() {
      return "kidd";
    }

    public function __get($property_name)
    {
      if(isset($this->$property_name))
      {
        return($this->$property_name);
      }else
      {
        return(NULL);
      }
    }

    private $name = 'kidd2';

  }
  $t = new test;
  echo $t->name."\n";

-------- 2016-08-17 11:08:56
why "echo json_encode($arr);" can be called directly without any "use" or "require" or "include"??


---------- 2016-08-16 14:24:33
<?php
  $arr = [1 => 'normal',
          4 => 'periodical'];

  print_r($arr);

  foreach($arr as $key => $value) {
    echo $key."\n";
  }

  echo json_encode($arr)."\n";
?>
$ php test.php

Array
(
    [1] => normal
    [4] => periodical
)
1
4
{"1":"normal","4":"periodical"}

---------- 2016-08-15 10:18:30
__get, without __get, accessing the private member will throw error:
PHP Fatal error:  Uncaught Error: Cannot access private property base::$age in /home/kidd/workspace/php/test.php:20

<?php
  class base {
    public function print($age=34) {
      echo "parent\n";
    }

    // public function __get($name) {
    //   return $this->$name;
    // }
    private $age;
  }
  $p = new base();
  $p->age = 2;
  echo $p->age;
?>

--------- 2016-08-12 10:00:20 
php 7 throws warnings if son function does not have the same args as the parent function.
<?php
  class base {
    public function print($age=34) {
      echo "parent\n";
    }
  }

  class son extends base {
    public function print() {
      echo "son\n";
    }
  }
  $p = new son();
  $p->print(67);
?>

$ php test.php
PHP Warning:  Declaration of son::print() should be compatible with base::print($age = 34) in /home/kidd/workspace/php/test.php on line 13

son

$ php -v
PHP 7.0.9-1+deb.sury.org~trusty+1 (cli) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
    with Zend OPcache v7.0.9-1+deb.sury.org~trusty+1, Copyright (c) 1999-2016, by Zend Technologies

------------ 2016-08-11 15:01:17
empty() 可以用来判定所有的数据类型是否为空或假，而 is_null 与 isset 基本一样，只能用来判断是否为NULL和未定义。


------- 2016-08-11 10:07:45
php 数组添加元素(可用关联数组)总结
http://www.111cn.net/phper/php/62892.htm

-------------- 2016-08-11 10:02:31
php reference
PHP foreach循环时是否复制一份出来循环?
  是的，如果想在循环时改变原数组的值，只需加个引用

    public function getCheckinList()
    {
        // unlike [bool]: unlike_count > like_count
        // veto [bool]: the checkin is vetoed by some admin
        $checkinList = (new \yii\db\Query())
            ->select(['user.username', 'user.head_img', 'checkin.id', 'checkin.checkin_time', 'checkin.photo', 'checkin.like_count', 'checkin.unlike_count', '[[veto_admin_id]] > -1 as veto'])
            ->from('checkin')
            ->innerJoin('challenge', 'checkin.challenge_id = challenge.id')
            ->leftJoin('user', 'challenge.user_id=user.id')
            ->where(['challenge.mission_id' => $this->id])
            ->orderBy(['checkin.checkin_time' => SORT_DESC])
            ->all();
        foreach ($checkinList as &$member) {
            $checkin = Checkin::findOne($member['id']);
            if(!empty($checkin)) {
                $member['valid'] = $checkin->isValid();
            }
            else {
                $member['valid'] = false;
            }
        }
        return $checkinList;
    }

--------- 2016-08-05 13:48:39
php中引用&的真正理解-变量引用、函数引用、对象引用
PHP 的引用允许你用两个变量来指向同一个内容 $b =&$a;
函数的传址调用 function test(&$a){} 要注意的是，在这里test(１);的话就会出错，原因是：PHP规定传递的引用不能为常量（可以看错误提示）。
函数的引用返回 function &test(){} 通过这种方式$a=test();得到的其实不是函数的引用返回，这跟普通的函数调用没有区别　至于原因：　这是ＰＨＰ的规定 ＰＨＰ规定通过$a=&test(); 方式得到的才是函数的引用返回
  $a=test()方式调用函数，只是将函数的值赋给$a而已，　而$a做任何改变，都不会影响到函数中的$b，而通过$a=&test()方式调用函数呢, 他的作用是　将return $b中的　$b变量的内存地址与$a变量的内存地址　指向了同一个地方 即产生了相当于这样的效果($a=&b;) 函数的引用返回多用在对象中
对象的引用 $b=new a; $c=$b; 在PHP5中 对象的复制是通过引用来实现的。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&$b; PHP5中默认就是通过引用来调用对象， 但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本 . 为了这样的目的，PHP定义了一个特殊的方法，称为__clone.
引用的作用
       如果程序比较大,引用同一个对象的变量比较多,并且希望用完该对象后手工清除它,个人建议用 "&" 方式,然后用$var=null的方式清除. 其它时候还是用php5的默认方式吧. 另外, php5中对于大数组的传递,建议用 "&" 方式, 毕竟节省内存空间使用。
取消引用 当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。<?php $a = 1; $b =& $a; unset ($a); ?>
  unset -> Undefined variable
  global 引用 当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：  
  <?php $var =& $GLOBALS["var"]; ?>

php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。
通俗的讲 1:如果有下面的代码 [php] $a="ABC"; $b=$a; [/php] 其实此时　$a与$b都是指向同一内存地址　而并不是$a与$b占用不同的内存
２:如果在上面的代码基础上再加上如下代码 [php] $a="EFG"; [/php] 由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断　自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储

  $a = 4;
  $b = &$a;
  echo $b."\n";
  $a = 5;
  echo $b."\n";
  unset($a);
  echo $a."\n";
  $a = 6;
  echo $b."\n";
output:
4
5
PHP Notice:  Undefined variable: a in /home/kidd/workspace/php/test.php on line 9
5


  $base = new Base;
  $base->user_count = 10;
  $ref = $base;
  $base->user_count = 11;
  echo $ref->user_count."\n";
  unset($base);
  echo $ref->user_count."\n";
  echo $base->user_count."\n";
output:
11
PHP Notice:  Undefined variable: base in /home/kidd/workspace/php/test.php on line 27
PHP Notice:  Trying to get property of non-object in /home/kidd/workspace/php/test.php on line 27

---------- 2016-08-05 12:39:10
var scope: PHP 中的每个变量都有一个针对它的作用域

<?php
  function function_name() {
    global $var; // without this line, below access will fail due to undefined var.
    echo "inside var: ".$var;
    $var = 23;;
  }
  $var=20;
  function_name(); // Function call.
  echo "outside var: ".$var;
?>
inside var: 20
outside var: 23

对于初学者来说，变量的作用域是它们所驻留的页面。因此，如果你定义了 $var，页面余下部分就可以访问 $var，但是，其它页面一般不能访问它（除非使用特殊的变量）。
因为包含文件像它们是原始（包含）脚本的一部分那样工作，所以在 include() 那一行之前定义的变量可供包含文件使用。此外，包含文件内定义的变量可供 include() 那一行之后的父（包含）脚本使用。

当使用你自己定义的函数时，所有这些都将变得不那么明显。这些函数具有它们自己的作用域，这意味着在一个函数内使用的变量不能在其外部使用，在一个函数外部定义的变量不能在其内部使用。由于这个原因，函数内部的变量可以具有与其外部的变量相同的名称，但是它们仍然是完全不同的变量，并且具有不同的值。对于大多数初级程序员来说，这是一个使人糊涂的概念。要改变一个函数内的变量的作用域，可以使用 global 语句。

避开变量作用域的另一个方法是利用超全局变量：$_GET、$_POST、$_REQUEST 等。这些变量在你的函数内是自动可访问的（因此，它们是超全局变量）。也可以添加元素到 $GLOBALS 数组中，使得可以在函数内使用它们。

PHP的常量是不是前面加const呢？让我们看一看。
不是的。在PHP必须用下面的方式定义。
bool define ( string name, mixed value [, bool case_insensitive] )
name 为常量名，value为常量的值。case_insensitive]为大小写敏感。默认为敏感。
常量一旦被声明将可以在全局可见，也就是说，它们可以函数内外使用，但是这仅仅限于一个页面之中（包含我们通过include和include_once）包含进来的PHP脚本，但是在其他的页面中就不能使用了。 
 常量和变量不同：
    常量前面没有美元符号（$）；
    常量只能用 define() 函数定义，而不能通过赋值语句；
    常量可以不用理会变量范围的规则而在任何地方定义和访问；
    常量一旦定义就不能被重新定义或者取消定义；
    常量的值只能是标量。

  function function_name() {
    define("CONSTANT", "Hello world.");
  }
  echo "\n".CONSTANT;

•在一个脚本中声明的全局变量在整个脚本中是可见的，但不是在函数内部，在函数内部的变量如果与全局变量名称相同，以函数内部的变量为准。
•函数内部使用的变量声明为全局变量时，其名称要与全局变量的名称一致，在这样的情况下，我们就可以在函数中使用函数外部的全局变量了，这样就可以避免上一种因为函数内部的变量与外部的全局变量名称相同而覆盖了外部变量这样的情况。
•在函数内部创建并声明为静态的变量无法在函数外部可见，但是可以在函数的多次执行过程中保持该值，最常见的情况就是在函数的递归执行的过程之中。
•在函数内部创建的变量对函数来说是本地的，而当函数终止时，该变量也就不存在了。
超级全局变量的完整列表如下：
•.$GOBALS 所有全局变量数组
•.$_SERVER 服务器环境变量数组
•.$_POST 通过POST方法传递给该脚本的变量数组
•.$_GET 通过GET方法传递给该脚本的变量数组
•.$_COOKIE cookie变量数组
•.$_FILES 与文件上传相关的变量数组
•.$_ENV 环境变量数组
•.$_REQUEST 所有用户输入的变量数组包括$_GET $_POST $_COOKIE 所包含的输入内容
•.$_SESSION 会话变量数组 

变量的范围即它定义的上下文背景（译者:说白了，也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。
在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 $GLOBALS["b"], the global var "b" is accessed.

static $int = 0; // correct
static $int = 1+2; // wrong (as it is an expression)
static $int = sqrt(121); // wrong (as it is an expression too)
静态变量可以按照上面的例子声明。如果在声明中用表达式的结果对其赋值会导致解析错误。

null(空值)：PHP中一种特殊的数据类型，表示空值，即表示没有为该变量设置任何值null(空值)不区分大小写，null和NULL是一样的。
被赋空值可能有三种情况：没有赋什么值、被赋空值null、被unset()函数处理过的变量（出处：《PHP从入门到精通》P47。
  $test = 3;
  unset($test);
  echo $test==null;
note: an unsetted var can not be printed [even the above comparison]
  PHP Notice:  Undefined variable: test in /home/kidd/workspace/php/test.php on line 31

------------ 2016-08-05 12:34:11
PHP empty、isset、isnull的区别
  empty
  如果 变量 是非空或非零的值，则 empty() 返回 FALSE。换句话说，”"、0、”0″、NULL、FALSE、array()、var $var、未定义;以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。
  isset
  如果 变量 存在(非NULL)则返回 TRUE，否则返回 FALSE(包括未定义）。变量值设置为：null，返回也是false;unset一个变量后，变量被取消了。注意，isset对于NULL值变量，特殊处理。
  is_null
  检测传入值【值，变量，表达式】是否是null,只有一个变量定义了，且它的值是null，它才返回TRUE . 其它都返回 FALSE 【未定义变量传入后会出错！】

--------- 2016-08-04 11:49:26
php json json_encode();给json数据编码， json_decode();是json数据变回以前的编码形式
可以利用PHP的数组，包括索引数组，包括关联数组，还有对象，来生成json数据
$usrInfo = array('usrname'=>'zhaogou','age'=>29,'sex'=>'male','tel'=>'028');
$jsdata=json_encode($usrInfo);
//如果是一个对象，则js数据中不会包含对象中的方法，如果属性是私有的也不能访问到.
$jstest = new jstest;
$jsclass=json_encode($jstest);

使用json的好处：
①节省服务器资源开销
②节省带宽
③按照需求来获得服务器的信息
④请求速度加快

function acceppt(){
  var xhr = creatXMLHttpRequest();
  xhr.onreadystatechange=function(){
    if(xhr.readyState==4 && xhr.status==200){
                  var linkMessage=xhr.responseText;
      eval("var jsondata ="+linkMessage);
      document.getElementById('content').innerHTML=jsondata.name+'<br/>'+jsondata.sex;
    }
  }
  xhr.open('get',"json.php");
  xhr.send(null);
}
由于返回的responseText数据是一大窜的字符串，ajax程序无法处理，因此需要将字符串转化为表达式


json_decode
(PHP 5 >= 5.2.0, PECL json >= 1.2.0)
json_decode — 对 JSON 格式的字符串进行编码
mixed json_decode ( string $json [, bool $assoc ] )
接受一个 JSON 格式的字符串并且把它转换为 PHP 变量  Returns an object or if the optional assoc parameter is TRUE, an associative array is instead returned. 

note: http://www.php100.com/cover/php/1093.html
Consider that JSON can differ between int and string. Numbers that cannot be handled by integer seems to become float casted.

json_decode: utf8

string json_encode ( mixed $value )
返回 value 值的 JSON 形式 
input: 待编码的 value ，除了resource 类型之外，可以为任何数据类型  该函数只能接受 UTF-8 编码的数据（译注：指字符/字符串类型的数据）

<?php
  $string = 'hello 到期 kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode;
?>
UTF-8

<?php
  $string = 'hello kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode;
?>
ASCII

http://www.php100.com/cover/php/1093.html

test: [the files was converted from utf-8 to ISO-8859], as seen from the output, json_encode does not generate any valid output.
 <?php
  $string = 'hello µ½ÆÚ kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode."\n";

  $arr = array ('a'=>$string,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

  $json_string = json_encode($arr);
  if(!$json_string) {
    echo 'json_encode returns false'.PHP_EOL;
  }
  $arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

  echo json_encode($arr);
?>
$ php gb_test.php 

EUC-CN
json_encode returns false
{"a":1,"b":2,"c":3,"d":4,"e":5}

$ file gb_test.php 
gb_test.php: ISO-8859 text

---------- 2016-08-04 11:33:29
XML CDATA的作用
操作XML文件时，如果允许用户输入内容，例如∶"< "、">"、"/"、""等，当生成XML时，会破坏了XML结构，使数据中断。
这就要用XML CDATA
在XML文档中的所有文本都会被解析器解析。
只有在CDATA部件之内的文本会被解析器忽略。 
不合法的XML字符必须被替换为相应的实体。 实体必须以符号"&"开头，以符号";"结尾。 注意: 只有"< " 字符和"&"字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。

在CDATA内部的所有内容都会被解析器忽略。
CDATA注意事项:
CDATA部件之间不能再包含CDATA部件（不能嵌套）。如果CDATA部件包含了字符"]]>" 或者"< ![CDATA[" ，将很有可能出错哦。
同样要注意在字符串"]]>"之间没有空格或者换行符


------------- 2016-08-04 10:02:11
"" works for \n, while '' not.
echo "\n";

http://www.jb51.net/article/53973.htm
使用总结：在字符串里面不需要加入 变量 或者 单引号(')和反斜杠(＼) 时，尽量用单引号引字符串，因为省去了双引号检查处理转义和解析变量上面的时间。能用单引号尽量用单引号。

①转义的字符不同
单引号和双引号中都可以使用转义字符(＼)，但只能转义在单引号中引起来的单引号和转义转义符本身。如果用双引号(“”)括起字符串，PHP懂得更多特殊字符串的转义序列。
②对变量的解析不同
单引号字符串中出现的变量不会被变量值替代。即PHP不会解析单引号中的变量，而是将变量名原样输出。双引号字符串最重要的一点是其中的变量名会被变量值替代，即可以解析双引号中包含的变量。
③解析速度不同
单引号不需要考虑变量的解析,速度比双引号快.推荐用单引号.有的时候双引号也比较好用,比如在拼凑sql 语句
附：echo '<br/>'; html中的标签在单引号和双引号中都有效。
------------- 2016-08-04 09:56:12
PHP 4 引入了 foreach 结构，和 Perl 以及其他语言很像。这只是一种遍历数组简便方法。foreach 仅能用于数组，当试图将其用于其它数据类型或者一个未初始化的变量时会产生错误。

foreach (array_expression as $value)
    statement
foreach (array_expression as $key => $value)
    statement
自PHP 5 起，还可能遍历对象。
注意：当 foreach 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 foreach 循环之前调用 reset()。
注意：除非数组是被引用，foreach 所操作的是指定数组的一个拷贝，而不是该数组本身。foreach对数组指针有些副作用。除非对其重置，在 foreach 循环中或循环后都不要依赖数组指针的值。
自 PHP 5 起，可以很容易地通过在 $value 之前加上 & 来修改数组的元素。此方法将以引用赋值而不是拷贝一个值。 foreach ($arr as &$value)

如果两次循环一个数组，一定不能这样写
foreach($arr as &$value){}
foreach($arr as $value){}
    这会导致第二次的循环的结果不正确(可能是php的bug吧)。可以用以下几种来代替：
//solution 1
foreach($arr as &$value){}
unset($value);
foreach($arr as $value){}
//solution 2
foreach($arr as &$value){}
foreach($arr as &$value){}
//solution 3
foreach($arr as &$value){}
$arr2 = $arr;
foreach($arr2 as $value){}
// solution 4
use another value name $value2 for the 2nd foreach

------------ 2016-08-04 09:51:55
array
在 PHP 中，有三种数组类型：
    索引数组 - 带有数字索引的数组 索引是自动分配的（索引从 0 开始）
    关联数组 - 带有指定键的数组
    多维数组 - 包含一个或多个数组的数组

<?php
  $cars=array("Volvo","BMW","SAAB");
  // echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";
  // print_r($cars);
  echo $cars['0'];
?>
count($cars); 获得数组的长度 - count() 函数

for($x=0;$x<$arrlength;$x++) 遍历索引数组
foreach($age as $x=>$x_value) 遍历关联数组

PHP 关联数组
$age=array("Peter"=>"35","Ben"=>"37","Joe"=>"43");
$age['Peter']="35";


---------- 2016-08-03 18:58:10
components/service/Wechat.php
    public static function postQrcodeTicket($post_data) {
        // $mpAccessToken = static::getMpAccessToken();
        $access_token = "Jfe4kLEOXJ6olLI2nXdiLehl8-l64cwGFdNR1euGUY1Cwp9Ngdcraq3--peOcGze0vHfPwQNnxALYnOnDxSV3cAO-oD602F3WITYuOi0pEdXiUVCxkEz4_q76MmqhB3zKGIbADAOKM";
        $url = "https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=".$access_token;
        $header = array(
            'Content-Type: application/json',
            'Content-Length: ' . strlen($post_data));
        $response = static::post_contents($url, $post_data, $header);
        return $response;
    }

    private static function post_contents($url, $post_data, $header) {
        Logger::logFunctionCall();
        $response =  Util::curl('POST', $url, $post_data, $header);
        if(empty($response['res'])){
            Logger::warning('post_contents failed');
            return false;
        }
        Logger::info('Response: ' . $response['res']);

        $response = json_decode($response['res'], true);
        if(!empty($response['errcode'])) {
            Logger::error(json_encode($response));
            return false;
        }
        return $response;
    }

components/service/Util.php
    public static function curl($method = 'POST', $url, $postData = null, $headers = null) {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );
        curl_setopt($ch, CURLOPT_TIMEOUT, 5);
        switch($method){
            case 'POST':
                curl_setopt($ch,CURLOPT_POST, 1 );
                break;
            case 'GET':
                curl_setopt($ch,CURLOPT_HTTPGET, 1);
                break;
            case 'PUT':
                curl_setopt($ch,CURLOPT_POST, 1 );
                curl_setopt($ch,CURLOPT_CUSTOMREQUEST, "PUT");
                break;
            case 'DELETE':curl_setopt($ch,CURLOPT_CUSTOMREQUEST, "DELETE");
                break;
            default:
                throw new AppException('Unsupported method: ' . $method);
                break;
        }

        if(!empty($postData)){
            curl_setopt ( $ch, CURLOPT_POSTFIELDS, $postData );
        }
        if(!empty($headers)){
            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        }
        $data['res'] = curl_exec($ch);
        $data['httpCode'] = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        return $data;
    }

------------ 2016-08-03 17:44:27
yii model rules is not reconfigured dynamically. e.g., below if does not work.
    public function rules()
    {
        if($this->type == 1) { // id is integer
            return [
                [['type', 'id'], 'required'],
                [['id'], 'integer'],
            ];
        }
        else {
            return [
                [['type', 'id'], 'required'],
                [['id'], 'string', 'max' => 64],
            ];
        }
    }

http://www.yiichina.com/tutorial/635
    public function rules()
    {
        return [
            [['type', 'scene_id', 'scene_str'], 'required'],
            [['scene_id'], 'integer'],
            [['scene_id'], 'compare', 'compareValue' => 1, 'operator' => '>='],
            [['scene_id'], 'compare', 'compareValue' => 100000, 'operator' => '<='],
            [['scene_str'], 'string', 'max' => 64],
        ];
    }

a validation method can be defined in model. 


------------ 2016-08-03 17:19:53
views/qrcode/create_confirm.php
<?php
/**
 * Created by PhpStorm.
 * User: anhye
 * Date: 16-8-3
 * Time: 11:50
 */
use yii\helpers\Html;
use yii\widgets\ActiveForm;
?>
<p>You have entered the following information:</p>

<ul>
    <li><label>type</label>: <?= Html::encode($model->type) ?></li>
    <li><label>id</label>: <?= Html::encode($model->id) ?></li>
    <li><label>ticket</label>: <?= Html::encode($model->ticket) ?></li>
    <li><label>http_code</label>: <?= Html::encode($model->http_code) ?></li>
</ul>

<img src="https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=<?= Html::encode($model->ticket) ?>" />

<hr />

<?php $form = ActiveForm::begin(); ?>

    <?php echo $form->field($model, 'type')->radioList(['1'=>'integer','0'=>'string']) ?>

    <?php echo $form->field($model, 'id') ?>

    <div class="form-group">
        <?= Html::submitButton('create', ['class' => 'btn btn-primary']) ?>
    </div>

<?php ActiveForm::end(); ?>

------------- 2016-08-03 16:40:19
$i = o;<?= $i ?>为什么输不出来结果呢？换成echo就能输出来，我很奇怪，是不是我的配置文件没配好，请大家帮帮我！谢谢

在php.ini文件中设置short_open_tag为on即可，但是不建议使用这种简短风格的写法！
规范写法：<?php echo $i; ?>


------------ 2016-08-03 14:10:16
http://www.cnblogs.com/caly/archive/2013/04/11/3013980.html
PHP 使用 curl 提交 json 格式数据

$data = array("name" => "Hagrid", "age" => "36");
$data_string = json_encode($data);

$ch = curl_init('http://api.local/rest/users');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
curl_setopt($ch, CURLOPT_POSTFIELDS,$data_string);
curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
    'Content-Type: application/json',
    'Content-Length: ' . strlen($data_string))
);
 
$result = curl_exec($ch);

http://www.jb51.net/article/35077.htm
PHP 数组和字符串互相转换实现方法
$array=explode(separator,$string);
$string=implode(glue,$array);

http://php.net/manual/en/function.json-decode.php
mixed json_decode ( string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0 ]]] )
  Takes a JSON encoded string and converts it into a PHP variable. 
   assoc
    When TRUE, returned objects will be converted into associative arrays.


--------- 2016-08-03 12:30:26
array

下标默认是从0开始
if key defined, access by key. otherwise by index.
if key is "1", item can be accessed via $array[1];

------------ 2016-07-29 17:30:16
require()函数会将目标档案的内容读入，并且把自己本身代换成这些读入的内容。
这个读入并且代换的动作是在 PHP 引擎编译你的程序代码的时候发生的，而不是发生在 PHP 引擎开始执行编译好的程序代码的时候（PHP 3.0 引擎的工作方式是编译一行执行一行，但是到了 PHP 4.0 就有所改变了，PHP 4.0 是先把整个程序代码全部编译完成后，再将这些编译好的程序代码一次执行完毕，在编译的过程中不会执行任何程序代码）。require() 通常来导入静态的内容，而 include() 则适合用来导入动态的程序代码。 

http://www.cnblogs.com/xia520pi/p/3697099.html
require()语句的性能与include()相类似，都是包括并运行指定文件。不同之处在于：对include()语句来说，在执行文件时每次都要进行读取和评估；而对于require()来说，文件只处理一次（实际上，文件内容替换require()语句）。这就意味着如果可能执行多次的代码，则使用require()效率比较高。另外一方面，如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用include()语句。
　　include引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。
　　require引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。

!!! no matter "include" or "require", __DIR__ is always where the exact file is located.

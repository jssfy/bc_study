
$ git clone https://github.com/php/php-src.git
Cloning into 'php-src'...
remote: Counting objects: 672048, done.
remote: Compressing objects: 100% (15/15), done.
Receiving objects:  95% (643793/672048), 233.82 MiB | 656.00 KiB/s

----------- 2016-08-07 20:57:56
http://blog.csdn.net/th362cn/article/details/8575344
PHP数组添加一个元素的方式： push(), arr[], 
    而且有实验证明，第二种方法的效率比第一种方法高出将近一倍！
    
<?php

 $t = microtime(true);
$array = array();
for($i = 0; $i < 10000; $i++) {
$array[] = $i;
}
print microtime(true) - $t;
print '<br>';
$t = microtime(true);
$array = array();
for($i = 0; $i < 10000; $i++) {
array_push($array, $i);
}
print microtime(true) - $t;


?>



----------- 2016-08-24 16:50:18

$body = "<xml><ToUserName><![CDATA[toUser]]></ToUserName>
  <FromUserName><![CDATA[FromUser]]></FromUserName>
  <CreateTime>123456789</CreateTime>
  <MsgType><![CDATA[event]]></MsgType>
  <Event><![CDATA[subscribe]]></Event>
  <EventKey><![CDATA[]]></EventKey>
  <Ticket><![CDATA[TICKET]]></Ticket>
  </xml>";
$xml = simplexml_load_string($body);

$temp = $xml->EventKey;
echo "EventKey is of type: ".get_class($temp)."\n";

$ php test.php
EventKey is of type: SimpleXMLElement

------- 2016-08-24 16:15:18
if(empty($test)) {
  echo "empty";
}
else {
  echo "not empty";
}

empty is true if $test is one of below: "", 0, null, false
劝告各位，千万注意使用empty()函数。
判断字符串是否为空，可以这么判断： if ($value=="") ...
* 格式：bool empty ( mixed var )
* 功能：检查一个变量是否为空
* 返回值：
* 若变量不存在则返回 TRUE
* 若变量存在且其值为""、0、"0"、NULL、、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 TURE
* 若变量存在且值不为""、0、"0"、NULL、、FALSE、 array()、var $var; 以及没有任何属性的对象，则返回 FALSE
* 版本：PHP 3, PHP 4, PHP 5

class Foo {
    protected $_date = '2014-07-21';

    public function __get($name) {
        $name = '_'.$name;
        return $this->$name;
    }
}
function is_empty($val) { return empty($val); }
$foo = new Foo();
echo $foo->date;  // 这里确实输出了日期值
if (empty($foo->date))
    echo "date is empty";
else
    echo "date is not empty";

if ( is_empty($foo->date))
    echo "date is empty";
else
    echo "date is not empty";

output:
2014-07-21date is emptydate is not empty

因为empty不是函数
使用is_empty的时候触发的是__get魔术方法，而empty触发的是__isset
http://php.net/manual/zh/language.oop5.overloading.php#object.isset 

empty是语言结构
使用is_empty的时候触发的是__get魔术方法，而empty触发的是__isset

    public function __isset($name) {
        $name = '_'.$name;
        return !empty($name);
    }

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Object.php
    /**
     * Checks if a property is set, i.e. defined and not null.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `isset($object->property)`.
     *
     * Note that if the property is not defined, false will be returned.
     * @param string $name the property name or the event name
     * @return boolean whether the named property is set (not null).
     * @see http://php.net/manual/en/function.isset.php
     */
    public function __isset($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter() !== null;
        } else {
            return false;
        }
    }

http://php.net/manual/en/function.empty.php
When using empty() on inaccessible object properties, the __isset() overloading method will be called, if declared. 

------------ 2016-08-24 15:12:44
without __isset, an attribute will be treated as empty by default. But a public member is not empty if it is set.

当对一个不可见的对象属性使用 empty() 时， __isset() 方法如果存在的话，它将会被调用。  

class Zend_Session_Namespace
{
  public $public_attr;
  private $parent_obj;
  private $session_key;
  public function __construct($params='')
  {
      $this->parent_obj=isset($_SESSION[$params])?(object)$_SESSION[$params]:new stdClass();
      $this->session_key=$params;
  }
  public function __get($name)
  {
      // TODO: Implement __get() method.
      if(isset($this->parent_obj->$name))
      {
          return($this->parent_obj->$name);
      }
      else
      {
          return(NULL);
      }
  }
  public function __set($name, $value)
  {
      // TODO: Implement __set() method.
      $this->parent_obj->$name = $value;
      $_SESSION[$this->session_key][$name]=$value;
  }
  //这个是后来加上的，加上这个，结果才对
  // public function __isset($name)
  // {
  //     return isset($this->parent_obj->$name);
  // }
}

echo "---------------";
$z = new Zend_Session_Namespace();

$z->public_attr = 'yeshello';
if(!empty($z->public_attr))
  echo "\n".strlen($z->public_attr);
else {
  echo "\n"."empty";
}


$z->parent_obj = 'yeshello';
if(!empty($z->parent_obj))
  echo "\n".strlen($z->parent_obj);
else {
  echo "\n"."empty";
}




------- 2016-08-24 11:32:26

PHP 5.3 ereg() 无法正常使用，提示“Function ereg() is deprecated Error”。
问题根源是php中有两种正则表示方法，一个是posix，一个是perl，php6打算废除posix的正则表示方法所以后来就加了个preg_match。此问题解决办法很简单，在ereg前加个过滤提示信息符号即可：把ereg()变成@ereg()。这样屏蔽了提示信息，但根本问题还是没有解决，php在5.2版本以前ereg都使用正常，在5.3以后，就要用preg_match来代替ereg。所以就需要变成这样。

原来：ereg("^[0-9]*$",$page)变成：preg_match("/^[0-9]*$/",$page)

特别提醒：posix与perl的很明显的表达区别就是是否加斜杠，所以与ereg相比，后者在正则的前后分别增加了两个"/"符号，不能缺少。

e.g., 

function valid_email($address) {
  // check an email address is possibly valid

  if (ereg('^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$', $address))
  =>
  if (preg_match('/^[a-zA-Z0-9_\.\-]+@[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-\.]+$/', $address))

---------- 2016-08-23 17:51:13
error_log:  

/var/log/php
$ subl error.log 


--------- 2016-08-23 14:22:09
http://www.cnblogs.com/wlgaojin/p/4684627.html
使用 self:: 或者 __CLASS__ 对当前类的静态引用，取决于定义当前方法所在的类：
使用 static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。
静态绑定是PHP 5.3.0，增加的一个功能 用于在继承范围内引用静态调用的类
self refers to the same class whose method the new operation takes place in.
static in PHP 5.3's late static bindings refers to whatever class in the hierarchy which you call the method on.

class Person
{
    public static function name()
    {
        echo "xiaosan";
    }
    public static function callself()
    {
        self::name();
    }

    public static function callstatic()
    {
        static::name();
    }
}

class Man extends Person
{
    public static function name()
    {
        echo "gaojin";
    }
}
Man::name();  // output： gaojin
Man::callself();  // output： xiaosan
Man::callstatic();  // output：xiaosan(子类调用 你懂的）

output:
  gaojinxiaosangaojin
---------- 2016-08-23 14:07:13
http://11463531.blog.hexun.com/81211052_d.html
this是指向当前对象的指针（可以看成C里面的指针），self是指向当前类的指针，parent是指向父类的指针。
parent是指向父类的指针，一般我们使用parent来调用父类的构造函数。
  parent::__construct( "PBPHome");    //使用parent调用了父类的构造函数 语句①
一般self使用来指向类中的静态变量。假如我们使用类里面静态（一般用关键字static）的成员，我们也必须使用self来调用。还要注意使用self来调用静态变量必须使用:: (域运算符号) self::$firstCount


------------ 2016-08-23 11:41:34
class A {
  public $age = 9;
  public static $array = array('localhost', '127.0.0.1', 'user', 'pwd');  
  const arr = array('localhost', '127.0.0.1', 'user', 'pwd');

  // get calling method name
  private static function getCallingMethodName() {
      $debug_trace = debug_backtrace();
      if ($debug_trace && count($debug_trace) > 2) {
          $class = isset($debug_trace[2]['class']) ? $debug_trace[2]['class'] : "GlobalFunction";
          return self::DEFAULT_CATEGORY_PREFIX . $class . '::' . $debug_trace[2]['function'];
      } else {
          return self::DEFAULT_CATEGORY_PREFIX . 'shit happens';
      }
  }

  public function test() {
    $debug_trace = debug_backtrace();
    echo json_encode($debug_trace);
  }

  public function inner() {
    $this->test();
  }

  public function outer() {
    $this->inner();
  }
}

[
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 25,
        "function": "test",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    },
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 29,
        "function": "inner",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    },
    {
        "file": "/home/kidd/workspace/php/test.php",
        "line": 41,
        "function": "outer",
        "class": "A",
        "object": {
            "age": 9
        },
        "type": "->",
        "args": []
    }
]

--------- 2016-08-23 11:21:24
$array=array('nihao','key'=>'chile');

echo "{$array['key']}"; // 花括号中的当作变量在使用进行解析处理

echo $array['key'];

$a='key';
echo "$array[$a]";

花括号并不是用来表示变量的，只是用来防止歧义

1.简单句法规则（用花括号界定变量名，适用于PHP所有版本）：
不管{是出现在$前面还是后面，只有两者紧挨着时花括号才会被当成是界定符号。不要在之间加空格，要不然就会被当作普通的花括号处理
echo "She received some { $a}s";
// 输出的结果为：She received some { flower}s
2.复杂句法规则（用花括号界定表达式等，使用与PHP4+）：
echo "有效的写法： {$arr[4][3]}";
// 有效；界定多维数组
echo "有效的写法： {$arr['foo'][3]}";
// 有效；当在字符串中使用多维数组时，一定要用括号将它括起来
echo "有效的写法： {$this->width}00";
// 有效；如果不界定的话，就会变成 $this->width00
echo "有效的写法： {$this->value[3]->name}";
// 有效；该例演示了界定链式调用
echo "有效的写法： $name: {${$name}}";
// 有效；该例演示的效果实际上是一个可变变量
echo "有效的写法: {${getName()}}";
// 有效；该例演示了将函数的返回值作为变量名
echo "有效的下发： {${$this->getName()}}";
// 有效；该例演示了将函数的返回值作为变量名
注意1：echo "这样写有效吗： {getName()}";输出结果为：'这样写有效吗：
{getName()}'。因为里面不含$，所以花括号不会被当作界定符
注意2：echo "这样写有效吗：{$arr[foo][3]}"; 在回答这个问题前我们先来进行一个实验：
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd'=>'e');
echo "This is $arr[d]";
// 我们发现这样写是没有问题的，那么我们像下面这样写呢？
echo $arr[d];
产生了这样的错误：
Notice: Use of undefined constant d - assumed 'd'
注意：采用了未定义的常量d，可能应该为'd'
那么如果我们像下面这样修改一下代码的话
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd'=>'e');
define('f', 'd');
echo $arr[f];
我们发现这次没有问题了。可以看出在字符串中数组的索引不加单引号是没有问题的，但是如果这种写法不是出现在字符串当中就会报错，而对于字符串中{$arr[foo][3]}的解析就是按照非字符串的方式解析的。所以说在字符串当中对数组只加花括号界定而不对索引加单引号的写法是错误的。因为程序会把不加单引号的索引当作是常量来进行解析，这就产生了错误。正确的写法应该是：
echo "有效的写法： {$arr['foo'][3]}";
特别提醒一点：echo "This is $arr[d]";这种写法虽然能够被程序解析，但这也仅限于数组是一维数组的情况。严谨的写法应该是：echo "This is {$arr['d']}";我的学生曾经在这一点上和我争论过，他说：既然前面一种写法能出结果，为什么一定要用后面一种写法呢？那么，我们再继续修改一下前面的代码
error_reporting(E_ALL);
$arr = array('a', 'b', 'c',
'd'=>array('e'=>'f')
);
echo "This is $arr[d][e]";
这样还能够被正确解析吗？我只想告诉你，加花括号是严谨的必要的。

注意3：
error_reporting(E_ALL);
$arr = array('a', 'b', 'c', 'd');
echo "This is {$arr[2]} 
";
echo "This is {$arr['2']} 
";
执行上面的代码。结果是一样的，为什么会这样呢？我只能告诉你PHP是弱类型语言，至于什么叫弱类型语言我就不在这里多说了。自己去Google一下吧。说了这么多，那么最能体现这些句法规则优势的具体应用在什么地方呢？----SQL语句
// 示例一：
$SQL1 = "select * from table where id={$_GET['id']}";
// 示例二：
$SQL2 = "select * from table where id={$this->id}";

----------- 2016-08-23 11:11:22
如果将一个字符串强制转换成一个数字.PHP会去搜索这个字符串的开头.如果开头是数字就转换.
逗号分隔开的就相当于是N个参数.也就是说把echo当个函数用.

http://php.net/manual/en/function.echo.php
// Strings can either be passed individually as multiple arguments or
// concatenated together and passed as a single argument
echo 'This ', 'string ', 'was ', 'made ', 'with multiple parameters.', chr(10);
echo 'This ' . 'string ' . 'was ' . 'made ' . 'with concatenation.' . "\n";

A benefit to passing in multiple arguments over using concatenation in echo regards the precedence of the period operator in PHP.

 With concatenation, the period operator has a higher precedence than both the addition and ternary operators, and so parentheses must be used for the correct behaviour:
<?php
echo 'Sum: ' . (1 + 2);
echo 'Hello ' . (isset($name) ? $name : 'John Doe') . '!';

----------- 2016-08-23 11:00:44
如下4种方式，都能得到同样的结果，但是，只有第4种方式是最好的。
$foo = 'John SMITH';
echo "Hello $foo, welcome on my website.";
echo "Hello " . $foo . " welcome on my website.";
echo 'Hello ' . $foo . ' welcome on my website.';
echo 'Hello ', $foo , ' welcome on my website.';

---------- 2016-08-22 11:59:20
json_encode (activerecord)
  is not as normal array. be careful.

e.g., if there is 1 ele, the output might be [{}]

use yii\helpers\Json;
Logger::info("uncheckedusers: ".Json::encode($period_mission->uncheckusers));
2016-08-22 12:07:38 [194][info][abc\app\components\MissionManager::getPeriodMissionCommonParam] uncheckedusers: [{"id":11,"account_type":"weixin","account_id":194,"nickname":"叶安华","username":"叶安华","passwd":null,"head_img":"http://wx.qlogo.cn/mmopen/PiajxSqBRaEJkp2ibNelHjpXwSUzqSaUIVRJ8Lxd9HtLDxMic2ziasKXY52oW5RLNLEH203qBoXUiavuZsp0aDnGGtQ/0","gender":1,"birthday":null,"phone":null,"regist_time":"2016-08-09 14:34:05","announce":null,"province":null,"city":null,"country":null,"updated_at":"2016-08-09 14:34:05","balance":0}]

----------- 2016-08-19 19:19:15

class A {
  public $age = 9;
}



$a = new A();
// var_dump(get_object_vars($a));
echo json_encode(get_object_vars($a));

------------ 2016-08-19 11:12:26
array:
  never use this: array([XXXXX]); this is not a simple array.

        $user_status = array(
            UserStatus::CANT_JOIN => false,
            UserStatus::CAN_JOIN => false,
            UserStatus::WAIT_CHECKIN => false,
            UserStatus::CAN_CHECKIN => false,
            UserStatus::ALREADY_CHECKIN => false,
            UserStatus::WAIT_REWARD => false,
            UserStatus::CAN_REWARD => false,
            UserStatus::CANT_REWARD => false,
            UserStatus::ALREADY_REWARD => false,
        );


---------- 2016-08-18 17:40:48

$now = time();
$count_down['next_time'] = date('Y-m-d 00:00:00', $now + 86400);

echo $count_down['next_time']."\n";

output:
  2016-08-19 00:00:00


-------- 2016-08-17 14:26:59
php property:

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Object.php
    /**
     * Returns the value of an object property.
     *
     * Do not call this method directly as it is a PHP magic method that
     * will be implicitly called when executing `$value = $object->property;`.
     * @param string $name the property name
     * @return mixed the property value
     * @throws UnknownPropertyException if the property is not defined
     * @throws InvalidCallException if the property is write-only
     * @see __set()
     */
    public function __get($name)
    {
        $getter = 'get' . $name;
        if (method_exists($this, $getter)) {
            return $this->$getter();
        } elseif (method_exists($this, 'set' . $name)) {
            throw new InvalidCallException('Getting write-only property: ' . get_class($this) . '::' . $name);
        } else {
            throw new UnknownPropertyException('Getting unknown property: ' . get_class($this) . '::' . $name);
        }
    }


class Component extends Object
class Model extends Component implements IteratorAggregate, ArrayAccess, Arrayable
abstract class BaseActiveRecord extends Model implements ActiveRecordInterface
class ActiveRecord extends BaseActiveRecord
class Mission extends \yii\db\ActiveRecord


/home/kidd/workspace/bc/MissionImpossible/models/PeriodMission.php
    public function getStop_time()
    {
        return date('Y-m-d H:i:s', strtotime($this->start_time) + $this->repeat * $this->period * 86400);
    }

------------ 2016-08-17 14:06:45
php event

/home/kidd/workspace/bc/MissionImpossible/vendor/yiisoft/yii2/base/Component.php
    /**
     * Triggers an event.
     * This method represents the happening of an event. It invokes
     * all attached handlers for the event including class-level handlers.
     * @param string $name the event name
     * @param Event $event the event parameter. If not set, a default [[Event]] object will be created.
     */
    public function trigger($name, Event $event = null)
    {
        $this->ensureBehaviors();
        if (!empty($this->_events[$name])) {
            if ($event === null) {
                $event = new Event;
            }
            if ($event->sender === null) {
                $event->sender = $this;
            }
            $event->handled = false;
            $event->name = $name;
            foreach ($this->_events[$name] as $handler) {
                $event->data = $handler[1];
                call_user_func($handler[0], $event);
                // stop further handling if the event is handled
                if ($event->handled) {
                    return;
                }
            }
        }
        // invoke class-level attached handlers
        Event::trigger($this, $name, $event);
    }

--------- 2016-08-17 14:05:11 __get
  class test{
    public function getName() {
      return "kidd";
    }

    public function __get($property_name)
    {
      if(isset($this->$property_name))
      {
        return($this->$property_name);
      }else
      {
        return(NULL);
      }
    }

    private $name = 'kidd2';

  }
  $t = new test;
  echo $t->name."\n";

-------- 2016-08-17 11:08:56
why "echo json_encode($arr);" can be called directly without any "use" or "require" or "include"??


---------- 2016-08-16 14:24:33
<?php
  $arr = [1 => 'normal',
          4 => 'periodical'];

  print_r($arr);

  foreach($arr as $key => $value) {
    echo $key."\n";
  }

  echo json_encode($arr)."\n";
?>
$ php test.php

Array
(
    [1] => normal
    [4] => periodical
)
1
4
{"1":"normal","4":"periodical"}

---------- 2016-08-15 10:18:30
__get, without __get, accessing the private member will throw error:
PHP Fatal error:  Uncaught Error: Cannot access private property base::$age in /home/kidd/workspace/php/test.php:20

<?php
  class base {
    public function print($age=34) {
      echo "parent\n";
    }

    // public function __get($name) {
    //   return $this->$name;
    // }
    private $age;
  }
  $p = new base();
  $p->age = 2;
  echo $p->age;
?>

--------- 2016-08-12 10:00:20 
php 7 throws warnings if son function does not have the same args as the parent function.
<?php
  class base {
    public function print($age=34) {
      echo "parent\n";
    }
  }

  class son extends base {
    public function print() {
      echo "son\n";
    }
  }
  $p = new son();
  $p->print(67);
?>

$ php test.php
PHP Warning:  Declaration of son::print() should be compatible with base::print($age = 34) in /home/kidd/workspace/php/test.php on line 13

son

$ php -v
PHP 7.0.9-1+deb.sury.org~trusty+1 (cli) ( NTS )
Copyright (c) 1997-2016 The PHP Group
Zend Engine v3.0.0, Copyright (c) 1998-2016 Zend Technologies
    with Zend OPcache v7.0.9-1+deb.sury.org~trusty+1, Copyright (c) 1999-2016, by Zend Technologies

------------ 2016-08-11 15:01:17
empty() 可以用来判定所有的数据类型是否为空或假，而 is_null 与 isset 基本一样，只能用来判断是否为NULL和未定义。


------- 2016-08-11 10:07:45
php 数组添加元素(可用关联数组)总结
http://www.111cn.net/phper/php/62892.htm

-------------- 2016-08-11 10:02:31
php reference
PHP foreach循环时是否复制一份出来循环?
  是的，如果想在循环时改变原数组的值，只需加个引用

    public function getCheckinList()
    {
        // unlike [bool]: unlike_count > like_count
        // veto [bool]: the checkin is vetoed by some admin
        $checkinList = (new \yii\db\Query())
            ->select(['user.username', 'user.head_img', 'checkin.id', 'checkin.checkin_time', 'checkin.photo', 'checkin.like_count', 'checkin.unlike_count', '[[veto_admin_id]] > -1 as veto'])
            ->from('checkin')
            ->innerJoin('challenge', 'checkin.challenge_id = challenge.id')
            ->leftJoin('user', 'challenge.user_id=user.id')
            ->where(['challenge.mission_id' => $this->id])
            ->orderBy(['checkin.checkin_time' => SORT_DESC])
            ->all();
        foreach ($checkinList as &$member) {
            $checkin = Checkin::findOne($member['id']);
            if(!empty($checkin)) {
                $member['valid'] = $checkin->isValid();
            }
            else {
                $member['valid'] = false;
            }
        }
        return $checkinList;
    }

--------- 2016-08-05 13:48:39
php中引用&的真正理解-变量引用、函数引用、对象引用
PHP 的引用允许你用两个变量来指向同一个内容 $b =&$a;
函数的传址调用 function test(&$a){} 要注意的是，在这里test(１);的话就会出错，原因是：PHP规定传递的引用不能为常量（可以看错误提示）。
函数的引用返回 function &test(){} 通过这种方式$a=test();得到的其实不是函数的引用返回，这跟普通的函数调用没有区别　至于原因：　这是ＰＨＰ的规定 ＰＨＰ规定通过$a=&test(); 方式得到的才是函数的引用返回
  $a=test()方式调用函数，只是将函数的值赋给$a而已，　而$a做任何改变，都不会影响到函数中的$b，而通过$a=&test()方式调用函数呢, 他的作用是　将return $b中的　$b变量的内存地址与$a变量的内存地址　指向了同一个地方 即产生了相当于这样的效果($a=&b;) 函数的引用返回多用在对象中
对象的引用 $b=new a; $c=$b; 在PHP5中 对象的复制是通过引用来实现的。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&$b; PHP5中默认就是通过引用来调用对象， 但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本 . 为了这样的目的，PHP定义了一个特殊的方法，称为__clone.
引用的作用
       如果程序比较大,引用同一个对象的变量比较多,并且希望用完该对象后手工清除它,个人建议用 "&" 方式,然后用$var=null的方式清除. 其它时候还是用php5的默认方式吧. 另外, php5中对于大数组的传递,建议用 "&" 方式, 毕竟节省内存空间使用。
取消引用 当你 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。<?php $a = 1; $b =& $a; unset ($a); ?>
  unset -> Undefined variable
  global 引用 当用 global $var 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的：  
  <?php $var =& $GLOBALS["var"]; ?>

php中对于地址的指向（类似指针）功能不是由用户自己来实现的，是由Zend核心实现的，php中引用采用的是“写时拷贝”的原理，就是除非发生写操作，指向同一个地址的变量或者对象是不会被拷贝的。
通俗的讲 1:如果有下面的代码 [php] $a="ABC"; $b=$a; [/php] 其实此时　$a与$b都是指向同一内存地址　而并不是$a与$b占用不同的内存
２:如果在上面的代码基础上再加上如下代码 [php] $a="EFG"; [/php] 由于$a与$b所指向的内存的数据要重新写一次了，此时Zend核心会自动判断　自动为$b生产一个$a的数据拷贝，重新申请一块内存进行存储

  $a = 4;
  $b = &$a;
  echo $b."\n";
  $a = 5;
  echo $b."\n";
  unset($a);
  echo $a."\n";
  $a = 6;
  echo $b."\n";
output:
4
5
PHP Notice:  Undefined variable: a in /home/kidd/workspace/php/test.php on line 9
5


  $base = new Base;
  $base->user_count = 10;
  $ref = $base;
  $base->user_count = 11;
  echo $ref->user_count."\n";
  unset($base);
  echo $ref->user_count."\n";
  echo $base->user_count."\n";
output:
11
PHP Notice:  Undefined variable: base in /home/kidd/workspace/php/test.php on line 27
PHP Notice:  Trying to get property of non-object in /home/kidd/workspace/php/test.php on line 27

---------- 2016-08-05 12:39:10
var scope: PHP 中的每个变量都有一个针对它的作用域

<?php
  function function_name() {
    global $var; // without this line, below access will fail due to undefined var.
    echo "inside var: ".$var;
    $var = 23;;
  }
  $var=20;
  function_name(); // Function call.
  echo "outside var: ".$var;
?>
inside var: 20
outside var: 23

对于初学者来说，变量的作用域是它们所驻留的页面。因此，如果你定义了 $var，页面余下部分就可以访问 $var，但是，其它页面一般不能访问它（除非使用特殊的变量）。
因为包含文件像它们是原始（包含）脚本的一部分那样工作，所以在 include() 那一行之前定义的变量可供包含文件使用。此外，包含文件内定义的变量可供 include() 那一行之后的父（包含）脚本使用。

当使用你自己定义的函数时，所有这些都将变得不那么明显。这些函数具有它们自己的作用域，这意味着在一个函数内使用的变量不能在其外部使用，在一个函数外部定义的变量不能在其内部使用。由于这个原因，函数内部的变量可以具有与其外部的变量相同的名称，但是它们仍然是完全不同的变量，并且具有不同的值。对于大多数初级程序员来说，这是一个使人糊涂的概念。要改变一个函数内的变量的作用域，可以使用 global 语句。

避开变量作用域的另一个方法是利用超全局变量：$_GET、$_POST、$_REQUEST 等。这些变量在你的函数内是自动可访问的（因此，它们是超全局变量）。也可以添加元素到 $GLOBALS 数组中，使得可以在函数内使用它们。

PHP的常量是不是前面加const呢？让我们看一看。
不是的。在PHP必须用下面的方式定义。
bool define ( string name, mixed value [, bool case_insensitive] )
name 为常量名，value为常量的值。case_insensitive]为大小写敏感。默认为敏感。
常量一旦被声明将可以在全局可见，也就是说，它们可以函数内外使用，但是这仅仅限于一个页面之中（包含我们通过include和include_once）包含进来的PHP脚本，但是在其他的页面中就不能使用了。 
 常量和变量不同：
    常量前面没有美元符号（$）；
    常量只能用 define() 函数定义，而不能通过赋值语句；
    常量可以不用理会变量范围的规则而在任何地方定义和访问；
    常量一旦定义就不能被重新定义或者取消定义；
    常量的值只能是标量。

  function function_name() {
    define("CONSTANT", "Hello world.");
  }
  echo "\n".CONSTANT;

•在一个脚本中声明的全局变量在整个脚本中是可见的，但不是在函数内部，在函数内部的变量如果与全局变量名称相同，以函数内部的变量为准。
•函数内部使用的变量声明为全局变量时，其名称要与全局变量的名称一致，在这样的情况下，我们就可以在函数中使用函数外部的全局变量了，这样就可以避免上一种因为函数内部的变量与外部的全局变量名称相同而覆盖了外部变量这样的情况。
•在函数内部创建并声明为静态的变量无法在函数外部可见，但是可以在函数的多次执行过程中保持该值，最常见的情况就是在函数的递归执行的过程之中。
•在函数内部创建的变量对函数来说是本地的，而当函数终止时，该变量也就不存在了。
超级全局变量的完整列表如下：
•.$GOBALS 所有全局变量数组
•.$_SERVER 服务器环境变量数组
•.$_POST 通过POST方法传递给该脚本的变量数组
•.$_GET 通过GET方法传递给该脚本的变量数组
•.$_COOKIE cookie变量数组
•.$_FILES 与文件上传相关的变量数组
•.$_ENV 环境变量数组
•.$_REQUEST 所有用户输入的变量数组包括$_GET $_POST $_COOKIE 所包含的输入内容
•.$_SESSION 会话变量数组 

变量的范围即它定义的上下文背景（译者:说白了，也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。
在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 $GLOBALS 数组。 $GLOBALS["b"], the global var "b" is accessed.

static $int = 0; // correct
static $int = 1+2; // wrong (as it is an expression)
static $int = sqrt(121); // wrong (as it is an expression too)
静态变量可以按照上面的例子声明。如果在声明中用表达式的结果对其赋值会导致解析错误。

null(空值)：PHP中一种特殊的数据类型，表示空值，即表示没有为该变量设置任何值null(空值)不区分大小写，null和NULL是一样的。
被赋空值可能有三种情况：没有赋什么值、被赋空值null、被unset()函数处理过的变量（出处：《PHP从入门到精通》P47。
  $test = 3;
  unset($test);
  echo $test==null;
note: an unsetted var can not be printed [even the above comparison]
  PHP Notice:  Undefined variable: test in /home/kidd/workspace/php/test.php on line 31

------------ 2016-08-05 12:34:11
PHP empty、isset、isnull的区别
  empty
  如果 变量 是非空或非零的值，则 empty() 返回 FALSE。换句话说，”"、0、”0″、NULL、FALSE、array()、var $var、未定义;以及没有任何属性的对象都将被认为是空的，如果 var 为空，则返回 TRUE。
  isset
  如果 变量 存在(非NULL)则返回 TRUE，否则返回 FALSE(包括未定义）。变量值设置为：null，返回也是false;unset一个变量后，变量被取消了。注意，isset对于NULL值变量，特殊处理。
  is_null
  检测传入值【值，变量，表达式】是否是null,只有一个变量定义了，且它的值是null，它才返回TRUE . 其它都返回 FALSE 【未定义变量传入后会出错！】

--------- 2016-08-04 11:49:26
php json json_encode();给json数据编码， json_decode();是json数据变回以前的编码形式
可以利用PHP的数组，包括索引数组，包括关联数组，还有对象，来生成json数据
$usrInfo = array('usrname'=>'zhaogou','age'=>29,'sex'=>'male','tel'=>'028');
$jsdata=json_encode($usrInfo);
//如果是一个对象，则js数据中不会包含对象中的方法，如果属性是私有的也不能访问到.
$jstest = new jstest;
$jsclass=json_encode($jstest);

使用json的好处：
①节省服务器资源开销
②节省带宽
③按照需求来获得服务器的信息
④请求速度加快

function acceppt(){
  var xhr = creatXMLHttpRequest();
  xhr.onreadystatechange=function(){
    if(xhr.readyState==4 && xhr.status==200){
                  var linkMessage=xhr.responseText;
      eval("var jsondata ="+linkMessage);
      document.getElementById('content').innerHTML=jsondata.name+'<br/>'+jsondata.sex;
    }
  }
  xhr.open('get',"json.php");
  xhr.send(null);
}
由于返回的responseText数据是一大窜的字符串，ajax程序无法处理，因此需要将字符串转化为表达式


json_decode
(PHP 5 >= 5.2.0, PECL json >= 1.2.0)
json_decode — 对 JSON 格式的字符串进行编码
mixed json_decode ( string $json [, bool $assoc ] )
接受一个 JSON 格式的字符串并且把它转换为 PHP 变量  Returns an object or if the optional assoc parameter is TRUE, an associative array is instead returned. 

note: http://www.php100.com/cover/php/1093.html
Consider that JSON can differ between int and string. Numbers that cannot be handled by integer seems to become float casted.

json_decode: utf8

string json_encode ( mixed $value )
返回 value 值的 JSON 形式 
input: 待编码的 value ，除了resource 类型之外，可以为任何数据类型  该函数只能接受 UTF-8 编码的数据（译注：指字符/字符串类型的数据）

<?php
  $string = 'hello 到期 kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode;
?>
UTF-8

<?php
  $string = 'hello kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode;
?>
ASCII

http://www.php100.com/cover/php/1093.html

test: [the files was converted from utf-8 to ISO-8859], as seen from the output, json_encode does not generate any valid output.
 <?php
  $string = 'hello µ½ÆÚ kidd';
  $encode = mb_detect_encoding($string, array("ASCII", "UTF-8","GB2312","GBK",'BIG5'));
  echo $encode."\n";

  $arr = array ('a'=>$string,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

  $json_string = json_encode($arr);
  if(!$json_string) {
    echo 'json_encode returns false'.PHP_EOL;
  }
  $arr = array ('a'=>1,'b'=>2,'c'=>3,'d'=>4,'e'=>5);

  echo json_encode($arr);
?>
$ php gb_test.php 

EUC-CN
json_encode returns false
{"a":1,"b":2,"c":3,"d":4,"e":5}

$ file gb_test.php 
gb_test.php: ISO-8859 text

---------- 2016-08-04 11:33:29
XML CDATA的作用
操作XML文件时，如果允许用户输入内容，例如∶"< "、">"、"/"、""等，当生成XML时，会破坏了XML结构，使数据中断。
这就要用XML CDATA
在XML文档中的所有文本都会被解析器解析。
只有在CDATA部件之内的文本会被解析器忽略。 
不合法的XML字符必须被替换为相应的实体。 实体必须以符号"&"开头，以符号";"结尾。 注意: 只有"< " 字符和"&"字符对于XML来说是严格禁止使用的。剩下的都是合法的，为了减少出错，使用实体是一个好习惯。

在CDATA内部的所有内容都会被解析器忽略。
CDATA注意事项:
CDATA部件之间不能再包含CDATA部件（不能嵌套）。如果CDATA部件包含了字符"]]>" 或者"< ![CDATA[" ，将很有可能出错哦。
同样要注意在字符串"]]>"之间没有空格或者换行符


------------- 2016-08-04 10:02:11
"" works for \n, while '' not.
echo "\n";

http://www.jb51.net/article/53973.htm
使用总结：在字符串里面不需要加入 变量 或者 单引号(')和反斜杠(＼) 时，尽量用单引号引字符串，因为省去了双引号检查处理转义和解析变量上面的时间。能用单引号尽量用单引号。

①转义的字符不同
单引号和双引号中都可以使用转义字符(＼)，但只能转义在单引号中引起来的单引号和转义转义符本身。如果用双引号(“”)括起字符串，PHP懂得更多特殊字符串的转义序列。
②对变量的解析不同
单引号字符串中出现的变量不会被变量值替代。即PHP不会解析单引号中的变量，而是将变量名原样输出。双引号字符串最重要的一点是其中的变量名会被变量值替代，即可以解析双引号中包含的变量。
③解析速度不同
单引号不需要考虑变量的解析,速度比双引号快.推荐用单引号.有的时候双引号也比较好用,比如在拼凑sql 语句
附：echo '<br/>'; html中的标签在单引号和双引号中都有效。
------------- 2016-08-04 09:56:12
PHP 4 引入了 foreach 结构，和 Perl 以及其他语言很像。这只是一种遍历数组简便方法。foreach 仅能用于数组，当试图将其用于其它数据类型或者一个未初始化的变量时会产生错误。

foreach (array_expression as $value)
    statement
foreach (array_expression as $key => $value)
    statement
自PHP 5 起，还可能遍历对象。
注意：当 foreach 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 foreach 循环之前调用 reset()。
注意：除非数组是被引用，foreach 所操作的是指定数组的一个拷贝，而不是该数组本身。foreach对数组指针有些副作用。除非对其重置，在 foreach 循环中或循环后都不要依赖数组指针的值。
自 PHP 5 起，可以很容易地通过在 $value 之前加上 & 来修改数组的元素。此方法将以引用赋值而不是拷贝一个值。 foreach ($arr as &$value)

如果两次循环一个数组，一定不能这样写
foreach($arr as &$value){}
foreach($arr as $value){}
    这会导致第二次的循环的结果不正确(可能是php的bug吧)。可以用以下几种来代替：
//solution 1
foreach($arr as &$value){}
unset($value);
foreach($arr as $value){}
//solution 2
foreach($arr as &$value){}
foreach($arr as &$value){}
//solution 3
foreach($arr as &$value){}
$arr2 = $arr;
foreach($arr2 as $value){}
// solution 4
use another value name $value2 for the 2nd foreach

------------ 2016-08-04 09:51:55
array
在 PHP 中，有三种数组类型：
    索引数组 - 带有数字索引的数组 索引是自动分配的（索引从 0 开始）
    关联数组 - 带有指定键的数组
    多维数组 - 包含一个或多个数组的数组

<?php
  $cars=array("Volvo","BMW","SAAB");
  // echo "I like " . $cars[0] . ", " . $cars[1] . " and " . $cars[2] . ".";
  // print_r($cars);
  echo $cars['0'];
?>
count($cars); 获得数组的长度 - count() 函数

for($x=0;$x<$arrlength;$x++) 遍历索引数组
foreach($age as $x=>$x_value) 遍历关联数组

PHP 关联数组
$age=array("Peter"=>"35","Ben"=>"37","Joe"=>"43");
$age['Peter']="35";


---------- 2016-08-03 18:58:10
components/service/Wechat.php
    public static function postQrcodeTicket($post_data) {
        // $mpAccessToken = static::getMpAccessToken();
        $access_token = "Jfe4kLEOXJ6olLI2nXdiLehl8-l64cwGFdNR1euGUY1Cwp9Ngdcraq3--peOcGze0vHfPwQNnxALYnOnDxSV3cAO-oD602F3WITYuOi0pEdXiUVCxkEz4_q76MmqhB3zKGIbADAOKM";
        $url = "https://api.weixin.qq.com/cgi-bin/qrcode/create?access_token=".$access_token;
        $header = array(
            'Content-Type: application/json',
            'Content-Length: ' . strlen($post_data));
        $response = static::post_contents($url, $post_data, $header);
        return $response;
    }

    private static function post_contents($url, $post_data, $header) {
        Logger::logFunctionCall();
        $response =  Util::curl('POST', $url, $post_data, $header);
        if(empty($response['res'])){
            Logger::warning('post_contents failed');
            return false;
        }
        Logger::info('Response: ' . $response['res']);

        $response = json_decode($response['res'], true);
        if(!empty($response['errcode'])) {
            Logger::error(json_encode($response));
            return false;
        }
        return $response;
    }

components/service/Util.php
    public static function curl($method = 'POST', $url, $postData = null, $headers = null) {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        curl_setopt( $ch, CURLOPT_SSL_VERIFYPEER, false );
        curl_setopt($ch, CURLOPT_TIMEOUT, 5);
        switch($method){
            case 'POST':
                curl_setopt($ch,CURLOPT_POST, 1 );
                break;
            case 'GET':
                curl_setopt($ch,CURLOPT_HTTPGET, 1);
                break;
            case 'PUT':
                curl_setopt($ch,CURLOPT_POST, 1 );
                curl_setopt($ch,CURLOPT_CUSTOMREQUEST, "PUT");
                break;
            case 'DELETE':curl_setopt($ch,CURLOPT_CUSTOMREQUEST, "DELETE");
                break;
            default:
                throw new AppException('Unsupported method: ' . $method);
                break;
        }

        if(!empty($postData)){
            curl_setopt ( $ch, CURLOPT_POSTFIELDS, $postData );
        }
        if(!empty($headers)){
            curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
        }
        $data['res'] = curl_exec($ch);
        $data['httpCode'] = curl_getinfo($ch, CURLINFO_HTTP_CODE);
        curl_close($ch);
        return $data;
    }

------------ 2016-08-03 17:44:27
yii model rules is not reconfigured dynamically. e.g., below if does not work.
    public function rules()
    {
        if($this->type == 1) { // id is integer
            return [
                [['type', 'id'], 'required'],
                [['id'], 'integer'],
            ];
        }
        else {
            return [
                [['type', 'id'], 'required'],
                [['id'], 'string', 'max' => 64],
            ];
        }
    }

http://www.yiichina.com/tutorial/635
    public function rules()
    {
        return [
            [['type', 'scene_id', 'scene_str'], 'required'],
            [['scene_id'], 'integer'],
            [['scene_id'], 'compare', 'compareValue' => 1, 'operator' => '>='],
            [['scene_id'], 'compare', 'compareValue' => 100000, 'operator' => '<='],
            [['scene_str'], 'string', 'max' => 64],
        ];
    }

a validation method can be defined in model. 


------------ 2016-08-03 17:19:53
views/qrcode/create_confirm.php
<?php
/**
 * Created by PhpStorm.
 * User: anhye
 * Date: 16-8-3
 * Time: 11:50
 */
use yii\helpers\Html;
use yii\widgets\ActiveForm;
?>
<p>You have entered the following information:</p>

<ul>
    <li><label>type</label>: <?= Html::encode($model->type) ?></li>
    <li><label>id</label>: <?= Html::encode($model->id) ?></li>
    <li><label>ticket</label>: <?= Html::encode($model->ticket) ?></li>
    <li><label>http_code</label>: <?= Html::encode($model->http_code) ?></li>
</ul>

<img src="https://mp.weixin.qq.com/cgi-bin/showqrcode?ticket=<?= Html::encode($model->ticket) ?>" />

<hr />

<?php $form = ActiveForm::begin(); ?>

    <?php echo $form->field($model, 'type')->radioList(['1'=>'integer','0'=>'string']) ?>

    <?php echo $form->field($model, 'id') ?>

    <div class="form-group">
        <?= Html::submitButton('create', ['class' => 'btn btn-primary']) ?>
    </div>

<?php ActiveForm::end(); ?>

------------- 2016-08-03 16:40:19
$i = o;<?= $i ?>为什么输不出来结果呢？换成echo就能输出来，我很奇怪，是不是我的配置文件没配好，请大家帮帮我！谢谢

在php.ini文件中设置short_open_tag为on即可，但是不建议使用这种简短风格的写法！
规范写法：<?php echo $i; ?>


------------ 2016-08-03 14:10:16
http://www.cnblogs.com/caly/archive/2013/04/11/3013980.html
PHP 使用 curl 提交 json 格式数据

$data = array("name" => "Hagrid", "age" => "36");
$data_string = json_encode($data);

$ch = curl_init('http://api.local/rest/users');
curl_setopt($ch, CURLOPT_CUSTOMREQUEST, "POST");
curl_setopt($ch, CURLOPT_POSTFIELDS,$data_string);
curl_setopt($ch, CURLOPT_RETURNTRANSFER,true);
curl_setopt($ch, CURLOPT_HTTPHEADER, array(
    'Content-Type: application/json',
    'Content-Length: ' . strlen($data_string))
);
 
$result = curl_exec($ch);

http://www.jb51.net/article/35077.htm
PHP 数组和字符串互相转换实现方法
$array=explode(separator,$string);
$string=implode(glue,$array);

http://php.net/manual/en/function.json-decode.php
mixed json_decode ( string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0 ]]] )
  Takes a JSON encoded string and converts it into a PHP variable. 
   assoc
    When TRUE, returned objects will be converted into associative arrays.


--------- 2016-08-03 12:30:26
array

下标默认是从0开始
if key defined, access by key. otherwise by index.
if key is "1", item can be accessed via $array[1];

------------ 2016-07-29 17:30:16
require()函数会将目标档案的内容读入，并且把自己本身代换成这些读入的内容。
这个读入并且代换的动作是在 PHP 引擎编译你的程序代码的时候发生的，而不是发生在 PHP 引擎开始执行编译好的程序代码的时候（PHP 3.0 引擎的工作方式是编译一行执行一行，但是到了 PHP 4.0 就有所改变了，PHP 4.0 是先把整个程序代码全部编译完成后，再将这些编译好的程序代码一次执行完毕，在编译的过程中不会执行任何程序代码）。require() 通常来导入静态的内容，而 include() 则适合用来导入动态的程序代码。 

http://www.cnblogs.com/xia520pi/p/3697099.html
require()语句的性能与include()相类似，都是包括并运行指定文件。不同之处在于：对include()语句来说，在执行文件时每次都要进行读取和评估；而对于require()来说，文件只处理一次（实际上，文件内容替换require()语句）。这就意味着如果可能执行多次的代码，则使用require()效率比较高。另外一方面，如果每次执行代码时是读取不同的文件，或者有通过一组文件迭代的循环，就使用include()语句。
　　include引入文件的时候，如果碰到错误，会给出提示，并继续运行下边的代码。
　　require引入文件的时候，如果碰到错误，会给出提示，并停止运行下边的代码。

!!! no matter "include" or "require", __DIR__ is always where the exact file is located.
